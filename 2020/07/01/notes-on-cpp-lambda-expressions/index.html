<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++ Lambda 表达式小记 - Daniel13265&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Daniel13265&#039;s Blog"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Daniel13265&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="C++ 中 lambda 表达式的一些相关内容。"><meta property="og:type" content="blog"><meta property="og:title" content="C++ Lambda 表达式小记"><meta property="og:url" content="https://daniel13265.github.io/2020/07/01/notes-on-cpp-lambda-expressions/"><meta property="og:site_name" content="Daniel13265&#039;s Blog"><meta property="og:description" content="C++ 中 lambda 表达式的一些相关内容。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://daniel13265.github.io/img/og_image.png"><meta property="article:published_time" content="2020-07-01T03:00:00.000Z"><meta property="article:modified_time" content="2020-07-01T03:00:00.000Z"><meta property="article:author" content="Daniel13265"><meta property="article:tag" content="Language"><meta property="article:tag" content="Notes"><meta property="article:tag" content="Programming"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://daniel13265.github.io/2020/07/01/notes-on-cpp-lambda-expressions/"},"headline":"C++ Lambda 表达式小记","image":["https://daniel13265.github.io/img/og_image.png"],"datePublished":"2020-07-01T03:00:00.000Z","dateModified":"2020-07-01T03:00:00.000Z","author":{"@type":"Person","name":"Daniel13265"},"publisher":{"@type":"Organization","name":"Daniel13265's Blog","logo":{"@type":"ImageObject","url":"https://daniel13265.github.io/img/avatar.png"}},"description":"C++ 中 lambda 表达式的一些相关内容。"}</script><link rel="canonical" href="https://daniel13265.github.io/2020/07/01/notes-on-cpp-lambda-expressions/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Daniel13265&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/daniel13265/daniel13265.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-07-01T03:00:00.000Z" title="7/1/2020, 11:00:00 AM">2020-07-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-07-01T03:00:00.000Z" title="7/1/2020, 11:00:00 AM">2020-07-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/Computer-Science/">Computer Science</a></span><span class="level-item">30 minutes read (About 4431 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">C++ Lambda 表达式小记</h1><div class="content"><p>C++ 中 lambda 表达式的一些相关内容。</p>
<span id="more"></span>
<p><div class="table-of-contents"><ul><li><a href="#0.-%E4%BB%80%E4%B9%88%E6%98%AF-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F">0. 什么是 lambda 表达式？</a></li><li><a href="#1.-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1. 基本语法</a></li><li><a href="#2.-%E9%97%AD%E5%8C%85">2. 闭包</a></li><li><a href="#3.-lambda-%E6%BC%94%E7%AE%97">3. Lambda 演算</a></li><li><a href="#4.-church-%E6%95%B0">4. Church 数</a></li><li><a href="#5.-oi-%E4%B8%AD%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">5. OI 中的 lambda 表达式</a></li><li><a href="#6.-boost-%E5%BA%93%E4%B8%AD%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">6. Boost 库中的 lambda 表达式</a></li></ul></div></p>
<h2 id="0-什么是-lambda-表达式？">0. 什么是 lambda 表达式？<a class="header-anchor" href="#0-什么是-lambda-表达式？">¶</a></h2>
<p>lambda 表达式是<strong>不被标识符命名绑定的函数声明</strong>。lambda 表达式也被称为<strong>匿名函数</strong>、<strong>函数字面量</strong>或者 <strong>lambda 抽象</strong>。通俗地讲，<strong>一个 lambda 表达式表示一个不具名的函数</strong>。</p>
<h2 id="1-基本语法">1. 基本语法<a class="header-anchor" href="#1-基本语法">¶</a></h2>
<p><strong>由于此部分内容在网上有大量解释，因此这里不再赘述，只放上了一些来自 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/lambda">Lambda 表达式 (C++11 起) - cppreference.com</a> 的内容。</strong></p>
<h3 id="基本格式">基本格式<a class="header-anchor" href="#基本格式">¶</a></h3>
<p>[ <em>捕获</em> ] ( <em>形参</em> ) <em>说明符</em> <em>异常说明</em> <em>attr</em> -&gt; <em>ret</em> { <em>函数体</em> }</p>
<h3 id="捕获"><em>捕获</em><a class="header-anchor" href="#捕获">¶</a></h3>
<p>此处为零或更多捕获符的逗号分隔列表，可选地以默认捕获符起始。</p>
<p>仅有的默认捕获符是</p>
<ul>
<li><code>&amp;</code> 以引用隐式捕获被使用的自动变量；</li>
<li><code>=</code> 以复制隐式捕获被使用的自动变量。</li>
</ul>
<p>当出现任一默认捕获符时，都能隐式捕获当前对象（<code>*this</code>）。当它被隐式捕获时，始终被以引用捕获，即使默认捕获符是 <code>=</code> 也是如此。</p>
<p><em>捕获</em> 中单独的捕获符的语法是</p>
<ul>
<li><em>标识符</em>  - 以复制捕获；</li>
<li><em>标识符</em><code>...</code> - 作为包展开的简单以复制捕获；</li>
<li><em>标识符</em> <em>初始化器</em>  - 带初始化器的以复制捕获；</li>
<li><code>&amp;</code> <em>标识符</em>  - 以引用捕获；</li>
<li><code>&amp;</code> <em>标识符</em><code>...</code> - 作为包展开的简单引用捕获；</li>
<li><code>&amp;</code> <em>标识符</em> <em>初始化器</em>  - 带初始化器的以引用捕获；</li>
<li><code>this</code> - 当前对象的简单以引用捕获；</li>
<li><code>*this</code> - 当前对象的简单以复制捕获。</li>
</ul>
<p>当默认捕获符是 <code>&amp;</code> 时，后继的简单捕获符必须不以 <code>&amp;</code> 开始。当默认捕获符是 <code>=</code> 时，后继的简单捕获符必须以 <code>&amp;</code> 开始或者为 <code>*this</code>。任何捕获符只可以出现一次。</p>
<p>特殊地，若变量满足下列条件，则 lambda 表达式可以不捕获就使用它。</p>
<ul>
<li>该变量为非局部变量，或具有静态或线程局部存储期（该情况下无法捕获该变量）；</li>
<li>该变量为以常量表达式初始化的引用。</li>
</ul>
<p>若变量满足下列条件，则 lambda 表达式可以不捕获就读取其值。</p>
<ul>
<li>该变量具有 <code>const</code> 而非 <code>volatile</code> 的整型或枚举类型，并已用常量表达式初始化；</li>
<li>该变量为 <code>constexpr</code> 且无 <code>mutable</code> 成员。</li>
</ul>
<h3 id="形参"><em>形参</em><a class="header-anchor" href="#形参">¶</a></h3>
<p>即形参列表，如在具名函数中，允许默认实参。当以 <code>auto</code> 为形参类型时，该 lambda 为泛型 lambda。</p>
<p>不接收实参的函数可以省略形参列表。仅当 <code>constexpr</code>、<code>mutable</code>、异常说明、属性或尾随返回类型全都不使用时才能使用此形式。</p>
<h3 id="说明符"><em>说明符</em><a class="header-anchor" href="#说明符">¶</a></h3>
<p>可选的说明符的序列。允许下列说明符：</p>
<ul>
<li><code>mutable</code> - 允许函数体修改各个复制捕获的对象，以及调用其非 <code>const</code> 成员函数；</li>
<li><code>constexpr</code> - 显式指定函数调用运算符为 <code>constexpr</code> 函数。此说明符不存在时，若函数调用运算符恰好满足针对 <code>constexpr</code> 函数的所有要求，则它也会是 <code>constexpr</code>。</li>
</ul>
<p>没有特殊说明符可以省略。</p>
<h3 id="异常说明"><em>异常说明</em><a class="header-anchor" href="#异常说明">¶</a></h3>
<p>为闭包类型的 <code>operator()</code> 提供异常说明或 <code>noexcept</code> 子句。不提供异常说明可以省略。</p>
<h3 id="attr"><em>attr</em><a class="header-anchor" href="#attr">¶</a></h3>
<p>为闭包类型的函数调用运算符的类型提供属性说明。这样指定的任何属性均属于函数调用运算符的类型，而非函数调用运算符自身。无属性声明可以省略。</p>
<h3 id="ret"><em>ret</em><a class="header-anchor" href="#ret">¶</a></h3>
<p>返回类型。若缺失，则由函数的 <code>return</code> 语句所蕴含（或当函数不返回任何值时为 <code>void</code>）。</p>
<h3 id="函数体"><em>函数体</em><a class="header-anchor" href="#函数体">¶</a></h3>
<p>函数体。</p>
<h3 id="例-1：使用示例">例 1：使用示例<a class="header-anchor" href="#例-1：使用示例">¶</a></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> counter1 = <span class="number">0</span>, counter2 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// [] &#123; ++counter1; &#125; ();</span></span><br><span class="line">  <span class="comment">// 错误，无法捕获 counter1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// [=] &#123; ++counter1; &#125; ();</span></span><br><span class="line">  <span class="comment">// 按拷贝捕获</span></span><br><span class="line">  <span class="comment">// 错误，counter1 默认为 const</span></span><br><span class="line">  </span><br><span class="line">  [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    ++counter2;</span><br><span class="line">  &#125; (); <span class="comment">// 正确，添加 mutable 后可以在 lambda 表达式中修改 counter1 和 counter2 值</span></span><br><span class="line">  std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; std::endl; <span class="comment">// 因为上面的 lambda 表达式捕获的是原对象的复制，所以输出 0 0</span></span><br><span class="line">  </span><br><span class="line">  [&amp;] &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    ++counter2;</span><br><span class="line">  &#125; (); <span class="comment">// 按引用捕获</span></span><br><span class="line">  std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; std::endl; <span class="comment">// 因为是原对象的引用，所以输出 1 1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  [=, &amp;counter2]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    ++counter2;</span><br><span class="line">  &#125; ();  <span class="comment">// 默认按拷贝捕获，counter2 按引用捕获</span></span><br><span class="line">  std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; std::endl; <span class="comment">// 输出 1 2</span></span><br><span class="line">  </span><br><span class="line">  [&amp;, counter2]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    ++counter2;</span><br><span class="line">  &#125; (); <span class="comment">// 默认按引用捕获，counter2 按拷贝捕获</span></span><br><span class="line">  std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; std::endl; <span class="comment">// 输出 2 2</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [=, counter2]() mutable &#123;</span></span><br><span class="line"><span class="comment">    ++counter1;</span></span><br><span class="line"><span class="comment">    ++counter2;</span></span><br><span class="line"><span class="comment">  &#125; ();</span></span><br><span class="line"><span class="comment">  [&amp;, &amp;counter2]() mutable &#123;</span></span><br><span class="line"><span class="comment">    ++counter1;</span></span><br><span class="line"><span class="comment">    ++counter2;</span></span><br><span class="line"><span class="comment">  &#125; ();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 警告或者错误，因为默认捕获方式与 counter2 的捕获方式相同</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [&amp;counter1, &amp;counter1] &#123;</span></span><br><span class="line"><span class="comment">    ++counter1;</span></span><br><span class="line"><span class="comment">  &#125; ();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 警告或者错误，因为 counter1 被捕获了两次</span></span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; [&amp;counter1 = counter2, counter2 = counter1 + <span class="number">1</span>] &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    <span class="keyword">return</span> counter2;</span><br><span class="line">  &#125; () &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line">  std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; std::endl;  <span class="comment">// 输出 2 3</span></span><br><span class="line">  <span class="comment">// 带有初始化器的捕获符</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="练习">练习<a class="header-anchor" href="#练习">¶</a></h3>
<p><strong>尝试计算以下程序的输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> counter1 = <span class="number">0</span>, counter2 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> getcount1 = [&amp;counter1 = counter2, counter2 = counter1 + <span class="number">1</span>](<span class="type">int</span> &amp;counter3) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    ++counter1;</span><br><span class="line">    ++counter2;</span><br><span class="line">    ++counter3;</span><br><span class="line">    std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> [counter1 = counter3 + <span class="number">1</span>, &amp;counter2 = counter3](<span class="type">int</span> &amp;counter3) <span class="keyword">mutable</span> &#123;</span><br><span class="line">      ++counter1;</span><br><span class="line">      ++counter2;</span><br><span class="line">      ++counter3;</span><br><span class="line">      std::cout &lt;&lt; counter1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter3 &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">getcount1</span>(counter2)(counter1);</span><br><span class="line">  ++counter1;</span><br><span class="line">  ++counter2;</span><br><span class="line">  <span class="built_in">getcount1</span>(counter2)(counter2);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> getcount2 = <span class="built_in">getcount1</span>(counter1);</span><br><span class="line">  <span class="built_in">getcount2</span>(counter2);</span><br><span class="line">  ++counter1;</span><br><span class="line">  ++counter2;</span><br><span class="line">  <span class="built_in">getcount2</span>(counter1);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-闭包">2. 闭包<a class="header-anchor" href="#2-闭包">¶</a></h2>
<p>在 C++ 中，lambda 表达式为<strong>纯右值表达式</strong>，其类型为<strong>闭包类型（Closure Type）</strong>。</p>
<h3 id="闭包捕获的对象">闭包捕获的对象<a class="header-anchor" href="#闭包捕获的对象">¶</a></h3>
<p>考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> count = [] &#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; ();</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>counter</code> 正常地进行了累加。当外层 lambda 表达式退出后，其中声明的 <code>counter</code> 被销毁，占用的空间被回收。而内层的 <code>counter</code> 接受了另外一个与外层 <code>counter</code> 值相同的 <code>counter</code>，它占用自己的独有内存地址，因此不会被销毁。但是如果内层的 lambda 表达式按引用捕获 <code>counter</code>，则它会随着外层闭包的销毁而销毁，因此此时再尝试取值则会产生错误。</p>
<p>可以通过以下程序证明以上说法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> getcount1 = [] &#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> count1 = <span class="built_in">getcount1</span>();</span><br><span class="line">  <span class="type">int</span> val1 = <span class="built_in">count1</span>();</span><br><span class="line">  std::cout &lt;&lt; val1 &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> getcount2 = [] &#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> [&amp;]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> count2 = <span class="built_in">getcount2</span>();</span><br><span class="line">  <span class="type">int</span> val2 = <span class="built_in">count2</span>();</span><br><span class="line">  std::cout &lt;&lt; val2 &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x843fecc</span><br><span class="line">0x843ff00</span><br><span class="line">1</span><br><span class="line">0x843fecc</span><br><span class="line">0x843fecc</span><br><span class="line">138673913</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，按照拷贝捕获时 <code>counter</code> 的内存地址变化了，因此不再是之前的 <code>counter</code>，可以继续访问；而按照引用捕获时 <code>counter</code> 的内存地址没有变化，因此 <code>counter</code> 随着外层 lambda 一并销毁了，之后再访问该位置上的值导致了非法访问。</p>
<h3 id="闭包的拷贝">闭包的拷贝<a class="header-anchor" href="#闭包的拷贝">¶</a></h3>
<p>在上述第一份代码的主函数 <code>return 0;</code> 前追加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> copy = count;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">copy</span>() &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们如同期望的那样对闭包内的成员进行了拷贝。</p>
<h3 id="闭包的指针">闭包的指针<a class="header-anchor" href="#闭包的指针">¶</a></h3>
<p>继续追加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *pointer = &amp;count;</span><br><span class="line">std::cout &lt;&lt; pointer-&gt;<span class="built_in">operator</span>()() &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line">std::cout &lt;&lt; (*pointer)() &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们如同期望的那样声明了指向闭包的指针，并且函数也能正常地调用。</p>
<h3 id="闭包的引用">闭包的引用<a class="header-anchor" href="#闭包的引用">¶</a></h3>
<p>继续追加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;reference = count;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">reference</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 7</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们如同期望的那样声明了闭包的引用，并且函数也能正常地调用。</p>
<p>结合以上三个部分内容可以看出，闭包与如同普通对象的表现相似，我们可以将其看做一个具有独特类型的普通对象。</p>
<h3 id="闭包的提及">闭包的提及<a class="header-anchor" href="#闭包的提及">¶</a></h3>
<p>观察到上述代码全部都在使用 <code>auto</code> 来提及 lambda 表达式，这是因为闭包类型不能被指名。任意两个新创建 lambda 表达式的类型都是不一样的，就算它们可能看起来一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> lambda1 = [] &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lambda2 = [] &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line">  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same_v&lt;<span class="keyword">decltype</span>(lambda1), <span class="keyword">decltype</span>(lambda2)&gt; &lt;&lt; std::endl; <span class="comment">// 输出 false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是通过拷贝、取址或者获取引用等方式得到的<strong>同一个闭包</strong>的复制、同一个闭包的指针或者同一个闭包的引用的类型依然是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">  <span class="keyword">auto</span> lambda = [] &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> copy1 = lambda;</span><br><span class="line">  <span class="keyword">auto</span> copy2 = lambda;</span><br><span class="line">  std::cout &lt;&lt; std::is_same_v&lt;<span class="keyword">decltype</span>(copy1), <span class="keyword">decltype</span>(copy2)&gt; &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> pointer1 = &amp;lambda;</span><br><span class="line">  <span class="keyword">auto</span> pointer2 = &amp;lambda;</span><br><span class="line">  std::cout &lt;&lt; std::is_same_v&lt;<span class="keyword">decltype</span>(pointer1), <span class="keyword">decltype</span>(pointer2)&gt; &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> &amp;reference1 = lambda;</span><br><span class="line">  <span class="keyword">auto</span> &amp;reference2 = lambda;</span><br><span class="line">  std::cout &lt;&lt; std::is_same_v&lt;<span class="keyword">decltype</span>(reference1), <span class="keyword">decltype</span>(reference2)&gt; &lt;&lt; std::endl; <span class="comment">// 输出 true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，无捕获的非泛型 lambda 表达式也可以被显示或隐式地转换为对应类型的 C 风格函数指针或者 <code>std::function</code> 并被指名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> (*plus1)(<span class="type">int</span>, <span class="type">int</span>) = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">  std::function plus2 = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;; <span class="comment">// 模板类型推导得到 plus2 的类型为 std::function&lt;int(int, int)&gt;</span></span><br><span class="line">  std::function&lt;<span class="type">char</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; plus3 = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">plus1</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">plus2</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">plus3</span>(<span class="number">24</span>, <span class="number">25</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3 7 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>无捕获的泛型 lambda 表达式可以显示或隐式地转化为特化后对应类型的 C 风格函数指针或者 <code>std::function</code> 并被指名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> (*plus1)(<span class="type">int</span>, <span class="type">int</span>) = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">  <span class="comment">// 正确，将两个 auto 都特化为了 int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// char (*plus2)(char, char) = [](auto x, auto y) &#123; return x + y; &#125;;</span></span><br><span class="line">  <span class="comment">// 错误，不可转换（char 相加的结果的类型为 int 而不是 char）</span></span><br><span class="line">  </span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; plus3 = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">  std::function&lt;<span class="type">char</span>(<span class="type">char</span>, <span class="type">char</span>)&gt; plus4 = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">  <span class="comment">// 正确，可以转换</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// std::function plus5 = [](auto x, auto y) &#123; return x + y; &#125;;</span></span><br><span class="line">  <span class="comment">// 错误，无法推导 plus5 的完整类型。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2：once">例 2：<code>once</code><a class="header-anchor" href="#例-2：once">¶</a></h3>
<p><s>（好像和前文没有什么关系）</s></p>
<p><strong>实现 <code>once</code>，它能够接受一个函数并将其返回，返回的函数只能调用一次。</strong></p>
<p>此操作可以使用结构体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">once</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Res, <span class="keyword">typename</span>... _ArgTypes&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">once</span>&lt;_Res(_ArgTypes...)&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;_Res(_ArgTypes...)&gt; function_type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">once</span>(function_type func) &#123;</span><br><span class="line">    func_pointer = <span class="keyword">new</span> <span class="built_in">function_type</span>(func);</span><br><span class="line">    called = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">once</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> func_pointer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> called;</span><br><span class="line">  function_type *func_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="function">_Res <span class="title">operator</span> <span class="params">()</span><span class="params">(_ArgTypes ...args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Function called more than once.&quot;</span>);</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> func_pointer-&gt;<span class="built_in">operator</span> ()(args...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而如果使用 lambda 闭包，写起来会更为简单直观：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> once = [](<span class="keyword">auto</span> func) &#123;</span><br><span class="line">  <span class="type">bool</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> ...args) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (called)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Function called more than once.&quot;</span>);</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(args...);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-Lambda-演算">3. Lambda 演算<a class="header-anchor" href="#3-Lambda-演算">¶</a></h2>
<p>使用 lambda 表达式可以简单地实现 lambda 演算（毕竟 lambda 表达式源于 lambda 演算）：</p>
<p>$$\begin{aligned}\operatorname{True}:\ &amp;\lambda x.\ \lambda y.\ x\\\operatorname{False}:\ &amp;\lambda x.\ \lambda y.\ y\end{aligned}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> True = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> <span class="comment">/*y*/</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> False = [](<span class="keyword">auto</span> <span class="comment">/*x*/</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-3：-operatorname-Pair">例 3：$\operatorname{Pair}$<a class="header-anchor" href="#例-3：-operatorname-Pair">¶</a></h3>
<p><strong>实现 $\operatorname{Pair}$，$\operatorname{First}$ 与 $\operatorname{Second}$，使得对于任意 $x,y$，有 $\operatorname{First}\ (\operatorname{Pair}\ x\ y)=x,\operatorname{Second}\ (\operatorname{Pair}\ x\ y)=y$。$\operatorname{Pair}$，$\operatorname{First}$ 与 $\operatorname{Second}$ 不需要对其他参数负责。</strong></p>
<p>可以简单地通过预接受参数来实现：</p>
<p>$$\begin{aligned}\operatorname{Pair}:\ &amp;\lambda x.\ \lambda y.\ \lambda s.\ s\ x\ y\\\operatorname{First}:\ &amp;\lambda x.\ x\ \operatorname{True}\\\operatorname{Second}:\ &amp;\lambda x.\ x\ \operatorname{False}\end{aligned}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Pair = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span> s) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">s</span>(x)(y);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> First = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">x</span>(True);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Second = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">x</span>(False);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习<a class="header-anchor" href="#练习-2">¶</a></h3>
<ol>
<li><strong>实现 $\operatorname{Swap}$，它能够将 $f$ 接受的两个表达式的位置交换。具体地，对于任意的 $f,x,y$，有 $\operatorname{Swap}\ f\ x\ y=f\ y\ x$。</strong></li>
<li><strong>实现 $\operatorname{Not},\operatorname{And},\operatorname{Or}$，使它们分别能够满足一般布尔运算逻辑。如 $\operatorname{Not}\ \operatorname{True}=\operatorname{False}$，$\operatorname{And}\ \operatorname{True}\ \operatorname{False}=\operatorname{False}$。$\operatorname{Not},\operatorname{And},\operatorname{Or}$ 不需要对其他参数负责。</strong></li>
<li><strong>实现 $\operatorname{Map}$，它能够将 $f$ 映射到 $\operatorname{Pair}$ 上。具体地，对于任意的 $f,x,y$，有 $\operatorname{Map}\ f\ (\operatorname{Pair}\ x\ y)=\operatorname{Pair}\ (f\ x)\ (f\ y)$。$\operatorname{Map}$ 不需要对其他参数负责。</strong></li>
</ol>
<h2 id="4-Church-数">4. Church 数<a class="header-anchor" href="#4-Church-数">¶</a></h2>
<p>同样地，我们可以简单地使用 lambda 表达式来表示 church 数：</p>
<p>$$\begin{aligned}\operatorname{Zero}:\ &amp;\lambda f.\ \lambda x.\ x\\\operatorname{Three}:\ &amp;\lambda f.\ \lambda x.\ f\ (f\ (f\ x))\end{aligned}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Zero = [](<span class="keyword">auto</span> <span class="comment">/*f*/</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者更简单地：</span></span><br><span class="line"><span class="comment">// auto Zero = False;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Three = [](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">f</span>(<span class="built_in">f</span>(x)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-4：-operatorname-Succ">例 4：$\operatorname{Succ}$<a class="header-anchor" href="#例-4：-operatorname-Succ">¶</a></h3>
<p><strong>实现函数 $\operatorname{Succ}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\operatorname{Succ}\ x$ 表示自然数 $X+1$。$\operatorname{Succ}$ 不需要对其他参数负责。</strong></p>
<p>同样可以让 $x$ 预接受参数 $f$ 来实现。</p>
<p>$$\operatorname{Succ}:\ \lambda x.\ \lambda f.\ \lambda v.\ f\ (x\ f\ v)$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Succ = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span> v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">x</span>(f)(v));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-5：-operatorname-Pred">例 5：$\operatorname{Pred}$<a class="header-anchor" href="#例-5：-operatorname-Pred">¶</a></h3>
<p><strong>实现函数 $\operatorname{Pred}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\operatorname{Pred}\ x$ 表示自然数 $X-1$。特殊地，$\operatorname{Pred}\ \operatorname{Zero}=\operatorname{Zero}$。$\operatorname{Pred}$ 不需要对其他参数负责。</strong></p>
<p>考虑使用 $\operatorname{Pair}$ 来创建一个类似于「缓冲区」的东西。具体地，对于一个 $\operatorname{Pair}\ x\ y$，让其变为 $\operatorname{Pair}\ (f\ x)\ x$，将重复操作 $X$ 次的此操作用 $\operatorname{Pair}\ \operatorname{Zero}\ \operatorname{Zero}$ 实例化，最后得到的 $\operatorname{Pair}$ 应用到 $\operatorname{Second}$ 上的值即为最终结果。</p>
<p>$$\operatorname{Pred}:\ \lambda x.\ \lambda f.\ \lambda v.\ \operatorname{Second}\ ((\lambda p.\ (\operatorname{Pair}\ (f\ (\operatorname{First}\ p))\ (\operatorname{First}\ p)))\ (\operatorname{Pair}\ v\ v))$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Pred = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span> v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Second</span>(<span class="built_in">x</span>([=](<span class="keyword">auto</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Pair</span>(<span class="built_in">f</span>(<span class="built_in">First</span>(p)))(<span class="built_in">First</span>(p));</span><br><span class="line">      &#125; )(<span class="built_in">Pair</span>(v)(v)));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-6：-operatorname-Plus">例 6：$\operatorname{Plus}$<a class="header-anchor" href="#例-6：-operatorname-Plus">¶</a></h3>
<p><strong>实现函数 $\operatorname{Plus}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，有 $\operatorname{Plus}\ x\ y$ 表示自然数 $X+Y$。$\operatorname{Plus}$ 不需要对其他参数负责。</strong></p>
<p>根据 church 数的定义将 $\operatorname{Succ}$ 应用到 $x$ 上即可求出接下来的 church 的第 $X$ 个后继。</p>
<p>$$\operatorname{Plus}:\ \lambda x.\ (x\ \operatorname{Succ})$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Plus = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">x</span>(Succ);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-7：-operatorname-IsZero">例  7：$\operatorname{IsZero}$<a class="header-anchor" href="#例-7：-operatorname-IsZero">¶</a></h3>
<p><strong>实现函数 $\operatorname{IsZero}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\operatorname{IsZero}\ x=\operatorname{False}$。特殊地，$\operatorname{IsZero}\ \operatorname{Zero}=\operatorname{True}$。$\operatorname{IsZero}$ 不需要对其他参数负责。</strong></p>
<p>考虑将一个永远返回 $\operatorname{False}$ 的函数应用到 $x$ 上再用 $\operatorname{True}$ 实例化。若 $\operatorname{IsZero}\ x$ 为 $\operatorname{True}$，则该函数不会被调用，返回 $\operatorname{True}$ ；否则会返回 $\operatorname{False}$。</p>
<p>$$\operatorname{IsZero}:\ \lambda x.\ x\ (\lambda t.\ \operatorname{False})\ \operatorname{True}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> IsZero = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">x</span>([](<span class="keyword">auto</span> <span class="comment">/*t*/</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> False;</span><br><span class="line">  &#125; )(True);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="练习-3">练习<a class="header-anchor" href="#练习-3">¶</a></h3>
<ol>
<li><strong>实现 $\operatorname{Mul},\operatorname{Pow},\operatorname{Minus}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，有 $\operatorname{Mul}\ x\ y$ 表示自然数 $XY$，$\operatorname{Pow}\ x\ y$ 表示自然数 $X^Y$，$\operatorname{Minus}\ x\ y$ 表示自然数 $X-Y$。特殊地，对于 $X&lt;Y$ 有 $\operatorname{Minus}\ x\ y=\operatorname{Zero}$。$\operatorname{Mul},\operatorname{Pow},\operatorname{Minus}$ 不需要对其他参数负责。</strong></li>
<li><strong>实现 $\operatorname{Leq},\operatorname{Less},\operatorname{Eq}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$ 满足一般自然数比较关系。如 $\operatorname{Leq}\ \operatorname{Three}\ \operatorname{Three}=\operatorname{True}$，$\operatorname{Less}\ \operatorname{Three}\ \operatorname{Zero}=\operatorname{False}$。$\operatorname{Leq},\operatorname{Less},\operatorname{Eq}$ 不需要对其他参数负责。</strong></li>
<li><strong>实现 $\operatorname{Min},\operatorname{Max}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，$\operatorname{Min}\ x\ y$ 为表示 $X,Y$ 中的较小值的 church 数，$\operatorname{Max}\ x\ y$ 为表示 $X,Y$ 中的较大值的 church 数。$\operatorname{Min},\operatorname{Max}$ 不需要对其他参数负责。</strong></li>
</ol>
<h3 id="例-8：-operatorname-Div">例  8：$\operatorname{Div}$<a class="header-anchor" href="#例-8：-operatorname-Div">¶</a></h3>
<p><strong>实现函数 $\operatorname{Div}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y(y\ne0)$，有 $\operatorname{Div}\ x\ y$ 表示自然数 $\left\lfloor\frac XY\right\rfloor$。$\operatorname{Div}$ 不需要对其他参数负责。</strong></p>
<p>考虑一个简单的除法步骤：</p>
<ul>
<li>若 $\operatorname{Less}\ x\ y$ 为 $\operatorname{True}$，则返回 $\operatorname{Zero}$，否则返回 $\operatorname{Succ}\ (\operatorname{Div}\ (\operatorname{Minus}\ x\ y)\ y)$。</li>
</ul>
<p>上述操作可以通过递归实现。具体地，考虑 lambda 表达式</p>
<p>$$H:\lambda f.\ \lambda x.\ \lambda y.\ \operatorname{Leq}\ y\ x\ (f\ f\ (\operatorname{Minus\ x\ y})\ y\ \operatorname{Zero})$$</p>
<p>那么将 $H$ 应用到 $H$ 上即可做递归调用，因此有</p>
<p>$$\operatorname{Div}:(\lambda f.\ \lambda x.\ \lambda y.\ \operatorname{Leq}\ y\ x\ (f\ f\ (\operatorname{Minus\ x\ y})\ y\ \operatorname{Zero}))\ (\lambda f.\ \lambda x.\ \lambda y.\ \operatorname{Leq}\ y\ x\ (f\ f\ (\operatorname{Minus\ x\ y})\ y\ \operatorname{Zero}))$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Div = [](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span> y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Leq</span>(y)(x)(<span class="built_in">Succ</span>(<span class="built_in">f</span>(f)(<span class="built_in">Minus</span>(x)(y))(y)))(Zero);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; ([](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span> y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Leq</span>(y)(x)(<span class="built_in">Succ</span>(<span class="built_in">f</span>(f)(<span class="built_in">Minus</span>(x)(y))(y)))(Zero);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>但是需要注意的是，上述代码会在编译期超出内存限制并编译失败，因为编译器不能够在编译时判断出 $\operatorname{Div}$ 的返回类型（lambda 表达式是两两不同的）。</strong></p>
<h2 id="5-OI-中的-lambda-表达式">5. OI 中的 lambda 表达式<a class="header-anchor" href="#5-OI-中的-lambda-表达式">¶</a></h2>
<p>OI 中的 lambda 表达式一般只是给患有命名困难综合征和/或懒癌的选手使用的。一般情况下只有像 <code>std::sort(a, a + n, [](int x, int y) &#123; return b[x] &lt; b[y]; &#125; );</code> 或 <code>std::for_each(v.begin(), v.end(), [t](int &amp;x) &#123; x += t; &#125; );</code> 这种简单的语句会用到。Lambda 表达式也可以用在函数内部另外声明函数。当然，如果你一定要在非必要的地方用 lambda 表达式来声明函数我也无话可说。</p>
<h2 id="6-Boost-库中的-lambda-表达式">6. Boost 库中的 lambda 表达式<a class="header-anchor" href="#6-Boost-库中的-lambda-表达式">¶</a></h2>
<p><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 库</a>提供了另外一种 lambda 表达式的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>; </span><br><span class="line">(boost::lambda::_1 += <span class="number">2</span>)(i);         <span class="comment">// i 现在为 3</span></span><br><span class="line">(std::cout &lt;&lt; ++boost::lambda::_1 &lt;&lt; std::endl)(i) <span class="comment">// i 现在为 4，输出 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体可以查看<a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_62_0/doc/html/lambda.html">此部分的官方文档</a>，这里不再展开。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++ Lambda 表达式小记</p><p><a href="https://daniel13265.github.io/2020/07/01/notes-on-cpp-lambda-expressions/">https://daniel13265.github.io/2020/07/01/notes-on-cpp-lambda-expressions/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Daniel13265</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-07-01</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2020-07-01</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Language/">Language</a><a class="link-muted mr-2" rel="tag" href="/tags/Notes/">Notes</a><a class="link-muted mr-2" rel="tag" href="/tags/Programming/">Programming</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/03/solution-coci2006-2007-4-jogurt/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">题解 【COCI2006-2007#4 -- JOGURT】</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/07/solution-luogu-p6021/"><span class="level-item">题解【洛谷 P6021 -- 洪水】</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Daniel13265"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Daniel13265</p><p class="is-size-6 is-block">Some Random Guy on the Internet</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/daniel13265"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://mivik.gitee.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Mivik</span></span><span class="level-right"><span class="level-item tag">mivik.gitee.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/Study/Competitive-Programming/"><span class="level-start"><span class="level-item">Competitive Programming</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Study/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Study/Discrete-Math/"><span class="level-start"><span class="level-item">Discrete Math</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binary-Search/"><span class="tag">Binary Search</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Brute-Force/"><span class="tag">Brute Force</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Constructive/"><span class="tag">Constructive</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structures/"><span class="tag">Data Structures</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Discrete-Fourier-Transform/"><span class="tag">Discrete Fourier Transform</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dynamic-Programming/"><span class="tag">Dynamic Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language/"><span class="tag">Language</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Math/"><span class="tag">Math</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Notes/"><span class="tag">Notes</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Programming/"><span class="tag">Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Segment-Tree/"><span class="tag">Segment Tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solution/"><span class="tag">Solution</span><span class="tag">10</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Daniel13265&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Daniel13265</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/daniel13265/daniel13265.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js" defer=""></script><script>
                window.addEventListener("load", function() {
                    document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                        renderMathInElement(element, {
                            delimiters: [
                                {left: "$$", right: "$$", display: true},
                                {left: "$", right: "$", display: false}
                            ]
                        });
                    });
                });
            </script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>