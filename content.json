{"pages":[{"title":"","text":"几乎不用的博客，不定期更新。","link":"/about"}],"posts":[{"title":"斯特林数及一些相关恒等式","text":"完全背不到，所以写个博客记一下。 一些特殊值的定义第一类斯特林数有无符号之间的相互转换特殊值生成函数递推式其他恒等式第二类斯特林数特殊值通项式生成函数递推式其他恒等式两类斯特林结合斯特林反演其他恒等式 一些特殊值的定义¶ 默认出现的字母都取非负值。 在本文中我们认为 $$ 0^0=1. $$ 对于 $n&lt;0$，$m&lt;0$ 或 $n&lt;m$ 的情况，定义 $$ \\begin{aligned} \\binom{n}{m}&amp;=0.\\\\ s\\left(n,m\\right)&amp;=0.\\\\ {n\\brack m}&amp;=0.\\\\ {n\\brace m}&amp;=0. \\end{aligned} $$ 对于 $n&lt;m$，定义 $$ \\sum_{k=m}^{n}f\\left(k\\right)=0. $$ 其中 $f\\left(k\\right)$ 为关于 $k$ 的任意函数。 第一类斯特林数¶ 记作 $s\\left(n,m\\right)$，无符号在 OI 中一般记作 $n\\brack m$。$n\\brack m$ 又称斯特林轮换数，表示将 $n$ 个两两不同的元素，划分为 $m$ 个非空环排列（圆排列）的方案数。 有无符号之间的相互转换¶ $$ \\begin{aligned} {n\\brack m}&amp;=\\left(-1\\right)^{n-m}s\\left(n,m\\right).\\\\ s\\left(n,m\\right)&amp;=\\left(-1\\right)^{n-m}{n\\brack m}.\\\\ \\end{aligned} $$ 特殊值¶ $$ \\begin{aligned} s\\left(n,0\\right)&amp;=\\left[n=0\\right].\\\\ s\\left(n,1\\right)&amp;=\\left(-1\\right)^{n-1}\\left(n-1\\right)!.\\qquad\\left(n\\ge1\\right)\\\\ s\\left(n,n-1\\right)&amp;=-\\binom{n}{2}.\\\\ s\\left(n,n\\right)&amp;=1.\\\\ \\end{aligned} $$ 生成函数¶ $$ \\begin{aligned} \\sum_{k=0}^ns\\left(n,k\\right)x^k&amp;=x^{\\underline n}.\\\\ \\sum_{k=0}^n{n\\brack k}x^{n-k}&amp;=\\prod_{k=1}^{n-1}\\left(1+kx\\right).\\\\ \\sum_{k=m}^{+\\infty}s\\left(k,m\\right)\\frac{x^k}{k!}&amp;=\\frac{\\ln^m\\left(1+x\\right)}{m!}.\\\\ \\sum_{k=m}^{+\\infty}{k\\brack m}\\frac{x^k}{k!}&amp;=\\frac{-\\ln^m\\left(1-x\\right)}{m!}. \\end{aligned} $$ 递推式¶ $$ \\begin{aligned} s\\left(n,m\\right)&amp;=s\\left(n-1,m-1\\right)-\\left(n-1\\right)s\\left(n-1,m\\right).\\qquad\\left(m\\ge1\\right)\\\\ {n\\brack m}&amp;={n-1\\brack m-1}+\\left(n-1\\right){n-1\\brack m}.\\qquad\\left(m\\ge1\\right) \\end{aligned} $$ $$ s\\left(n,m\\right)=\\sum_{k=m}^nn^{k-m}s\\left(n+1,k+1\\right).\\qquad\\left(m\\ge1\\right) $$ $$ \\begin{aligned} {n\\brack m}&amp;=\\sum_{k=m}^{n}\\binom{k-1}{m-1}{n-1\\brack k-1}.\\qquad\\left(m\\ge1\\right)\\\\ {n\\brack m}&amp;=\\sum_{k=m}^{n}\\frac{\\left(n-1\\right)!}{\\left(k-1\\right)!}{k-1\\brack m-1}.\\qquad\\left(m\\ge1\\right)\\\\ \\end{aligned} $$ $$ \\binom{m}{r}s\\left(n,m\\right)=\\sum_{k=m-r}^{n-r}\\binom{n}{k}s\\left(n-k,r\\right)s\\left(k,m-r\\right). $$ 其他恒等式¶ $$ \\sum_{k=1}^ns\\left(n,k\\right)=\\left[n=1\\right]. $$ $$ \\sum_{k=0}^n{n\\brack k}=n!. $$ 第二类斯特林数¶ 在 OI 中一般记作 $n\\brace m$，又称斯特林子集数，表示将 $n$ 个两两不同的元素，划分为 $m$ 个非空子集的方案数。 特殊值¶ $$ \\begin{aligned} {n\\brace n-1}&amp;=\\binom{n}{2}.\\\\ {n\\brace n}&amp;=1. \\end{aligned} $$ 通项式¶ $$ {n\\brace m}=\\sum_{k=0}^m\\frac{\\left(-1\\right)^k}{k!}\\cdot\\frac{\\left(m-k\\right)^n}{\\left(m-k\\right)!} $$ 生成函数¶ $$ \\sum_{k=m}^{+\\infty}{k\\brace m}x^k=\\frac{x^m}{\\prod_{k=1}^{m}\\left(1-kx\\right).} $$ $$ \\sum_{k=m}^{+\\infty}{k\\brace m}\\frac{x^k}{k!}=\\frac{\\left(e^x-1\\right)^m}{m!}. $$ $$ \\sum_{k=0}^n{n\\brace k}x^{\\underline k}=x^n. $$ 递推式¶ $$ {n\\brace m}={n-1\\brace m-1}+m{n-1\\brace m}.\\qquad\\left(m\\ge1\\right) $$ $$ {n\\brace m}=\\sum_{k=m}^nm^{n-k}{k-1\\brace m-1}.\\qquad\\left(m\\ge1\\right) $$ $$ {n\\brace m}=\\sum_{k=m}^n\\binom{n-1}{k-1}{k-1\\brace m-1}.\\qquad\\left(m\\ge1\\right) $$ $$ \\left(n+1\\right)m!{n\\brace m}=\\sum_{k=m}^{n}\\frac{\\left(-1\\right)^{k-m}}{k-m+1}\\left(k+1\\right)!{n+1\\brace k+1}. $$ 其他恒等式¶ $$ \\sum_{k=1}^n\\left(-1\\right)^k\\left(k-1\\right)!{n\\brace k}=\\left[n=1\\right]. $$ 两类斯特林结合¶ 斯特林反演¶ $$ \\begin{aligned} \\sum_{k=m}^n\\left(-1\\right)^{n-k}{n\\brack k}{k\\brace m}&amp;=\\left[m=n\\right].\\\\ \\sum_{k=m}^n\\left(-1\\right)^{n-k}{n\\brace k}{k\\brack m}&amp;=\\left[m=n\\right]. \\end{aligned} $$ $$ \\begin{aligned} f_n=\\sum_{i=0}^n{n\\brack i}g_i\\iff&amp;g_n=\\sum_{i=0}^n\\left(-1\\right)^{n-i}{n\\brace i}f_i.\\\\ f_n=\\sum_{i=m}^n{i\\brack n}g_i\\iff&amp;g_n=\\sum_{i=n}^m\\left(-1\\right)^{i-n}{i\\brace n}f_i.\\\\ f_n=\\sum_{i=0}^n{n\\brace i}g_i\\iff&amp;g_n=\\sum_{i=0}^n\\left(-1\\right)^{n-i}{n\\brack i}f_i.\\\\ f_n=\\sum_{i=n}^m{i\\brace n}g_i\\iff&amp;g_n=\\sum_{i=n}^m\\left(-1\\right)^{i-n}{i\\brack n}f_i. \\end{aligned} $$ 其他恒等式¶ $$ \\begin{aligned} {n\\brack m}&amp;=\\sum_{i=m}^n\\sum_{j=m}^i\\left(-1\\right)^{j-m}{n\\brack i}{i\\brack j}{j\\brace m}.\\\\ {n\\brace m}&amp;=\\sum_{i=m}^n\\sum_{j=m}^i\\left(-1\\right)^{j-m}{n\\brace i}{i\\brace j}{j\\brack m}. \\end{aligned} $$ $$ \\begin{aligned} {n\\brack m}&amp;=\\sum_{k=0}^{n-m}\\left(-1\\right)^{k-m+n}\\binom{k+n-1}{k+n-m}\\binom{2n-m}{n-k-m}{k-m+n\\brace k}.\\qquad\\left(m\\ge1\\right)\\\\ {n\\brace m}&amp;=\\sum_{k=0}^{n-m}\\left(-1\\right)^{k-m+n}\\binom{k+n-1}{k+n-m}\\binom{2n-m}{n-k-m}{k-m+n\\brack k}.\\qquad\\left(m\\ge1\\right) \\end{aligned} $$","link":"/2020/12/17/stirling-number-and-some-related-equations/"},{"title":"C++ Lambda 表达式小记","text":"C++ 中 lambda 表达式的一些相关内容。 0. 什么是 lambda 表达式？1. 基本语法2. 闭包3. Lambda 演算4. Church 数5. OI 中的 lambda 表达式6. Boost 库中的 lambda 表达式 0. 什么是 lambda 表达式？¶ lambda 表达式是不被标识符命名绑定的函数声明。lambda 表达式也被称为匿名函数、函数字面量或者 lambda 抽象。通俗地讲，一个 lambda 表达式表示一个不具名的函数。 1. 基本语法¶ 由于此部分内容在网上有大量解释，因此这里不再赘述，只放上了一些来自 Lambda 表达式 (C++11 起) - cppreference.com 的内容。 基本格式¶ [ 捕获 ] ( 形参 ) 说明符 异常说明 attr -&gt; ret { 函数体 } 捕获¶ 此处为零或更多捕获符的逗号分隔列表，可选地以默认捕获符起始。 仅有的默认捕获符是 &amp; 以引用隐式捕获被使用的自动变量； = 以复制隐式捕获被使用的自动变量。 当出现任一默认捕获符时，都能隐式捕获当前对象（*this）。当它被隐式捕获时，始终被以引用捕获，即使默认捕获符是 = 也是如此。 捕获 中单独的捕获符的语法是 标识符 - 以复制捕获； 标识符... - 作为包展开的简单以复制捕获； 标识符 初始化器 - 带初始化器的以复制捕获； &amp; 标识符 - 以引用捕获； &amp; 标识符... - 作为包展开的简单引用捕获； &amp; 标识符 初始化器 - 带初始化器的以引用捕获； this - 当前对象的简单以引用捕获； *this - 当前对象的简单以复制捕获。 当默认捕获符是 &amp; 时，后继的简单捕获符必须不以 &amp; 开始。当默认捕获符是 = 时，后继的简单捕获符必须以 &amp; 开始或者为 *this。任何捕获符只可以出现一次。 特殊地，若变量满足下列条件，则 lambda 表达式可以不捕获就使用它。 该变量为非局部变量，或具有静态或线程局部存储期（该情况下无法捕获该变量）； 该变量为以常量表达式初始化的引用。 若变量满足下列条件，则 lambda 表达式可以不捕获就读取其值。 该变量具有 const 而非 volatile 的整型或枚举类型，并已用常量表达式初始化； 该变量为 constexpr 且无 mutable 成员。 形参¶ 即形参列表，如在具名函数中，允许默认实参。当以 auto 为形参类型时，该 lambda 为泛型 lambda。 不接收实参的函数可以省略形参列表。仅当 constexpr、mutable、异常说明、属性或尾随返回类型全都不使用时才能使用此形式。 说明符¶ 可选的说明符的序列。允许下列说明符： mutable - 允许函数体修改各个复制捕获的对象，以及调用其非 const 成员函数； constexpr - 显式指定函数调用运算符为 constexpr 函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr 函数的所有要求，则它也会是 constexpr。 没有特殊说明符可以省略。 异常说明¶ 为闭包类型的 operator() 提供异常说明或 noexcept 子句。不提供异常说明可以省略。 attr¶ 为闭包类型的函数调用运算符的类型提供属性说明。这样指定的任何属性均属于函数调用运算符的类型，而非函数调用运算符自身。无属性声明可以省略。 ret¶ 返回类型。若缺失，则由函数的 return 语句所蕴含（或当函数不返回任何值时为 void）。 函数体¶ 函数体。 例 1：使用示例¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;int main() { int counter1 = 0, counter2 = 0; // [] { ++counter1; } (); // 错误，无法捕获 counter1 // [=] { ++counter1; } (); // 按拷贝捕获 // 错误，counter1 默认为 const [=]() mutable { ++counter1; ++counter2; } (); // 正确，添加 mutable 后可以在 lambda 表达式中修改 counter1 和 counter2 值 std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; std::endl; // 因为上面的 lambda 表达式捕获的是原对象的复制，所以输出 0 0 [&amp;] { ++counter1; ++counter2; } (); // 按引用捕获 std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; std::endl; // 因为是原对象的引用，所以输出 1 1 [=, &amp;counter2]() mutable { ++counter1; ++counter2; } (); // 默认按拷贝捕获，counter2 按引用捕获 std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; std::endl; // 输出 1 2 [&amp;, counter2]() mutable { ++counter1; ++counter2; } (); // 默认按引用捕获，counter2 按拷贝捕获 std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; std::endl; // 输出 2 2 /* [=, counter2]() mutable { ++counter1; ++counter2; } (); [&amp;, &amp;counter2]() mutable { ++counter1; ++counter2; } (); */ // 警告或者错误，因为默认捕获方式与 counter2 的捕获方式相同 /* [&amp;counter1, &amp;counter1] { ++counter1; } (); */ // 警告或者错误，因为 counter1 被捕获了两次 std::cout &lt;&lt; [&amp;counter1 = counter2, counter2 = counter1 + 1] { ++counter1; return counter2; } () &lt;&lt; std::endl; // 输出 3 std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; std::endl; // 输出 2 3 // 带有初始化器的捕获符 return 0;} 练习¶ 尝试计算以下程序的输出。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() { int counter1 = 0, counter2 = 0; auto getcount1 = [&amp;counter1 = counter2, counter2 = counter1 + 1](int &amp;counter3) mutable { ++counter1; ++counter2; ++counter3; std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; ' ' &lt;&lt; counter3 &lt;&lt; std::endl; return [counter1 = counter3 + 1, &amp;counter2 = counter3](int &amp;counter3) mutable { ++counter1; ++counter2; ++counter3; std::cout &lt;&lt; counter1 &lt;&lt; ' ' &lt;&lt; counter2 &lt;&lt; ' ' &lt;&lt; counter3 &lt;&lt; std::endl; }; }; getcount1(counter2)(counter1); ++counter1; ++counter2; getcount1(counter2)(counter2); auto getcount2 = getcount1(counter1); getcount2(counter2); ++counter1; ++counter2; getcount2(counter1); return 0;} 2. 闭包¶ 在 C++ 中，lambda 表达式为纯右值表达式，其类型为闭包类型（Closure Type）。 闭包捕获的对象¶ 考虑如下代码： 1234567891011121314#include &lt;iostream&gt;int main() { auto count = [] { int counter = 0; return [=]() mutable { return ++counter; }; } (); std::cout &lt;&lt; count() &lt;&lt; std::endl; // 输出 1 std::cout &lt;&lt; count() &lt;&lt; std::endl; // 输出 2 return 0;} 可以看到，counter 正常地进行了累加。当外层 lambda 表达式退出后，其中声明的 counter 被销毁，占用的空间被回收。而内层的 counter 接受了另外一个与外层 counter 值相同的 counter，它占用自己的独有内存地址，因此不会被销毁。但是如果内层的 lambda 表达式按引用捕获 counter，则它会随着外层闭包的销毁而销毁，因此此时再尝试取值则会产生错误。 可以通过以下程序证明以上说法： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() { auto getcount1 = [] { int counter = 0; std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl; return [=]() mutable { std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl; return ++counter; }; }; auto count1 = getcount1(); int val1 = count1(); std::cout &lt;&lt; val1 &lt;&lt; std::endl; auto getcount2 = [] { int counter = 0; std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl; return [&amp;]() mutable { std::cout &lt;&lt; &amp;counter &lt;&lt; std::endl; return ++counter; }; }; auto count2 = getcount2(); int val2 = count2(); std::cout &lt;&lt; val2 &lt;&lt; std::endl; return 0;} 可能的输出： 12345670x843fecc0x843ff0010x843fecc0x843fecc138673913 可以看到，按照拷贝捕获时 counter 的内存地址变化了，因此不再是之前的 counter，可以继续访问；而按照引用捕获时 counter 的内存地址没有变化，因此 counter 随着外层 lambda 一并销毁了，之后再访问该位置上的值导致了非法访问。 闭包的拷贝¶ 在上述第一份代码的主函数 return 0; 前追加如下代码： 123auto copy = count;std::cout &lt;&lt; copy() &lt;&lt; std::endl; // 输出 3std::cout &lt;&lt; count() &lt;&lt; std::endl; // 输出 3 可以看到，我们如同期望的那样对闭包内的成员进行了拷贝。 闭包的指针¶ 继续追加如下代码： 1234auto *pointer = &amp;count;std::cout &lt;&lt; pointer-&gt;operator()() &lt;&lt; std::endl; // 输出 4std::cout &lt;&lt; (*pointer)() &lt;&lt; std::endl; // 输出 5std::cout &lt;&lt; count() &lt;&lt; std::endl; // 输出 6 可以看到，我们如同期望的那样声明了指向闭包的指针，并且函数也能正常地调用。 闭包的引用¶ 继续追加如下代码： 123auto &amp;reference = count;std::cout &lt;&lt; reference() &lt;&lt; std::endl; // 输出 7std::cout &lt;&lt; count() &lt;&lt; std::endl; // 输出 8 可以看到，我们如同期望的那样声明了闭包的引用，并且函数也能正常地调用。 结合以上三个部分内容可以看出，闭包与如同普通对象的表现相似，我们可以将其看做一个具有独特类型的普通对象。 闭包的提及¶ 观察到上述代码全部都在使用 auto 来提及 lambda 表达式，这是因为闭包类型不能被指名。任意两个新创建 lambda 表达式的类型都是不一样的，就算它们可能看起来一样： 1234567891011#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;type_traits&gt;int main() { auto lambda1 = [] { return 1; }; auto lambda2 = [] { return 1; }; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same_v&lt;decltype(lambda1), decltype(lambda2)&gt; &lt;&lt; std::endl; // 输出 false return 0;} 但是通过拷贝、取址或者获取引用等方式得到的同一个闭包的复制、同一个闭包的指针或者同一个闭包的引用的类型依然是一样的： 1234567891011121314151617181920212223#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;type_traits&gt;int main() { std::cout &lt;&lt; std::boolalpha; auto lambda = [] { return 1; }; auto copy1 = lambda; auto copy2 = lambda; std::cout &lt;&lt; std::is_same_v&lt;decltype(copy1), decltype(copy2)&gt; &lt;&lt; std::endl; // 输出 true auto pointer1 = &amp;lambda; auto pointer2 = &amp;lambda; std::cout &lt;&lt; std::is_same_v&lt;decltype(pointer1), decltype(pointer2)&gt; &lt;&lt; std::endl; // 输出 true auto &amp;reference1 = lambda; auto &amp;reference2 = lambda; std::cout &lt;&lt; std::is_same_v&lt;decltype(reference1), decltype(reference2)&gt; &lt;&lt; std::endl; // 输出 true return 0;} 另外，无捕获的非泛型 lambda 表达式也可以被显示或隐式地转换为对应类型的 C 风格函数指针或者 std::function 并被指名： 123456789101112#include &lt;functional&gt;#include &lt;iostream&gt;int main() { int (*plus1)(int, int) = [](int x, int y) { return x + y; }; std::function plus2 = [](int x, int y) { return x + y; }; // 模板类型推导得到 plus2 的类型为 std::function&lt;int(int, int)&gt; std::function&lt;char(int, int)&gt; plus3 = [](int x, int y) { return x + y; }; std::cout &lt;&lt; plus1(1, 2) &lt;&lt; ' ' &lt;&lt; plus2(3, 4) &lt;&lt; ' ' &lt;&lt; plus3(24, 25) &lt;&lt; std::endl; // 输出 3 7 1 return 0;} 无捕获的泛型 lambda 表达式可以显示或隐式地转化为特化后对应类型的 C 风格函数指针或者 std::function 并被指名： 12345678910111213141516171819#include &lt;functional&gt;int main() { int (*plus1)(int, int) = [](auto x, auto y) { return x + y; }; // 正确，将两个 auto 都特化为了 int // char (*plus2)(char, char) = [](auto x, auto y) { return x + y; }; // 错误，不可转换（char 相加的结果的类型为 int 而不是 char） std::function&lt;int(int, int)&gt; plus3 = [](auto x, auto y) { return x + y; }; std::function&lt;char(char, char)&gt; plus4 = [](auto x, auto y) { return x + y; }; // 正确，可以转换 // std::function plus5 = [](auto x, auto y) { return x + y; }; // 错误，无法推导 plus5 的完整类型。 return 0;} 例 2：once¶ （好像和前文没有什么关系） 实现 once，它能够接受一个函数并将其返回，返回的函数只能调用一次。 此操作可以使用结构体实现： 123456789101112131415161718192021222324252627282930#include &lt;functional&gt;#include &lt;new&gt;#include &lt;stdexcept&gt;template &lt;typename...&gt;struct once;template &lt;typename _Res, typename... _ArgTypes&gt;struct once&lt;_Res(_ArgTypes...)&gt; { typedef std::function&lt;_Res(_ArgTypes...)&gt; function_type; once(function_type func) { func_pointer = new function_type(func); called = false; } ~once() { delete func_pointer; } bool called; function_type *func_pointer; _Res operator ()(_ArgTypes ...args) { if (called) throw std::runtime_error(&quot;Function called more than once.&quot;); called = true; return func_pointer-&gt;operator ()(args...); }}; 然而如果使用 lambda 闭包，写起来会更为简单直观： 123456789101112#include &lt;stdexcept&gt;auto once = [](auto func) { bool called = false; return [=](auto ...args) mutable { if (called) throw std::runtime_error(&quot;Function called more than once.&quot;); called = true; return func(args...); };}; 3. Lambda 演算¶ 使用 lambda 表达式可以简单地实现 lambda 演算（毕竟 lambda 表达式源于 lambda 演算）： $$\\begin{aligned}\\operatorname{True}:\\ &amp;\\lambda x.\\ \\lambda y.\\ x\\\\\\operatorname{False}:\\ &amp;\\lambda x.\\ \\lambda y.\\ y\\end{aligned}$$ 1234567891011auto True = [](auto x) { return [=](auto /*y*/) { return x; };};auto False = [](auto /*x*/) { return [=](auto y) { return y; };}; 例 3：$\\operatorname{Pair}$¶ 实现 $\\operatorname{Pair}$，$\\operatorname{First}$ 与 $\\operatorname{Second}$，使得对于任意 $x,y$，有 $\\operatorname{First}\\ (\\operatorname{Pair}\\ x\\ y)=x,\\operatorname{Second}\\ (\\operatorname{Pair}\\ x\\ y)=y$。$\\operatorname{Pair}$，$\\operatorname{First}$ 与 $\\operatorname{Second}$ 不需要对其他参数负责。 可以简单地通过预接受参数来实现： $$\\begin{aligned}\\operatorname{Pair}:\\ &amp;\\lambda x.\\ \\lambda y.\\ \\lambda s.\\ s\\ x\\ y\\\\\\operatorname{First}:\\ &amp;\\lambda x.\\ x\\ \\operatorname{True}\\\\\\operatorname{Second}:\\ &amp;\\lambda x.\\ x\\ \\operatorname{False}\\end{aligned}$$ 1234567891011121314auto Pair = [](auto x) { return [=](auto y) { return [=](auto s) { return s(x)(y); }; };};auto First = [](auto x) { return x(True);};auto Second = [](auto x) { return x(False);}; 练习¶ 实现 $\\operatorname{Swap}$，它能够将 $f$ 接受的两个表达式的位置交换。具体地，对于任意的 $f,x,y$，有 $\\operatorname{Swap}\\ f\\ x\\ y=f\\ y\\ x$。 实现 $\\operatorname{Not},\\operatorname{And},\\operatorname{Or}$，使它们分别能够满足一般布尔运算逻辑。如 $\\operatorname{Not}\\ \\operatorname{True}=\\operatorname{False}$，$\\operatorname{And}\\ \\operatorname{True}\\ \\operatorname{False}=\\operatorname{False}$。$\\operatorname{Not},\\operatorname{And},\\operatorname{Or}$ 不需要对其他参数负责。 实现 $\\operatorname{Map}$，它能够将 $f$ 映射到 $\\operatorname{Pair}$ 上。具体地，对于任意的 $f,x,y$，有 $\\operatorname{Map}\\ f\\ (\\operatorname{Pair}\\ x\\ y)=\\operatorname{Pair}\\ (f\\ x)\\ (f\\ y)$。$\\operatorname{Map}$ 不需要对其他参数负责。 4. Church 数¶ 同样地，我们可以简单地使用 lambda 表达式来表示 church 数： $$\\begin{aligned}\\operatorname{Zero}:\\ &amp;\\lambda f.\\ \\lambda x.\\ x\\\\\\operatorname{Three}:\\ &amp;\\lambda f.\\ \\lambda x.\\ f\\ (f\\ (f\\ x))\\end{aligned}$$ 1234567891011121314auto Zero = [](auto /*f*/) { return [=](auto x) { return x; };};// 或者更简单地：// auto Zero = False;auto Three = [](auto f) { return [=](auto x) { return f(f(f(x))); };}; 例 4：$\\operatorname{Succ}$¶ 实现函数 $\\operatorname{Succ}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\\operatorname{Succ}\\ x$ 表示自然数 $X+1$。$\\operatorname{Succ}$ 不需要对其他参数负责。 同样可以让 $x$ 预接受参数 $f$ 来实现。 $$\\operatorname{Succ}:\\ \\lambda x.\\ \\lambda f.\\ \\lambda v.\\ f\\ (x\\ f\\ v)$$ 12345678auto Succ = [](auto x) { return [=](auto f) { return [=](auto v) { return f(x(f)(v)); }; };}; 例 5：$\\operatorname{Pred}$¶ 实现函数 $\\operatorname{Pred}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\\operatorname{Pred}\\ x$ 表示自然数 $X-1$。特殊地，$\\operatorname{Pred}\\ \\operatorname{Zero}=\\operatorname{Zero}$。$\\operatorname{Pred}$ 不需要对其他参数负责。 考虑使用 $\\operatorname{Pair}$ 来创建一个类似于「缓冲区」的东西。具体地，对于一个 $\\operatorname{Pair}\\ x\\ y$，让其变为 $\\operatorname{Pair}\\ (f\\ x)\\ x$，将重复操作 $X$ 次的此操作用 $\\operatorname{Pair}\\ \\operatorname{Zero}\\ \\operatorname{Zero}$ 实例化，最后得到的 $\\operatorname{Pair}$ 应用到 $\\operatorname{Second}$ 上的值即为最终结果。 $$\\operatorname{Pred}:\\ \\lambda x.\\ \\lambda f.\\ \\lambda v.\\ \\operatorname{Second}\\ ((\\lambda p.\\ (\\operatorname{Pair}\\ (f\\ (\\operatorname{First}\\ p))\\ (\\operatorname{First}\\ p)))\\ (\\operatorname{Pair}\\ v\\ v))$$ 12345678910auto Pred = [](auto x) { return [=](auto f) { return [=](auto v) { return Second(x([=](auto p) { return Pair(f(First(p)))(First(p)); } )(Pair(v)(v))); }; };}; 例 6：$\\operatorname{Plus}$¶ 实现函数 $\\operatorname{Plus}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，有 $\\operatorname{Plus}\\ x\\ y$ 表示自然数 $X+Y$。$\\operatorname{Plus}$ 不需要对其他参数负责。 根据 church 数的定义将 $\\operatorname{Succ}$ 应用到 $x$ 上即可求出接下来的 church 的第 $X$ 个后继。 $$\\operatorname{Plus}:\\ \\lambda x.\\ (x\\ \\operatorname{Succ})$$ 1234auto Plus = [](auto x) { return x(Succ);}; 例 7：$\\operatorname{IsZero}$¶ 实现函数 $\\operatorname{IsZero}$，使得对于任意表示自然数 $X$ 的 church 数 $x$，有 $\\operatorname{IsZero}\\ x=\\operatorname{False}$。特殊地，$\\operatorname{IsZero}\\ \\operatorname{Zero}=\\operatorname{True}$。$\\operatorname{IsZero}$ 不需要对其他参数负责。 考虑将一个永远返回 $\\operatorname{False}$ 的函数应用到 $x$ 上再用 $\\operatorname{True}$ 实例化。若 $\\operatorname{IsZero}\\ x$ 为 $\\operatorname{True}$，则该函数不会被调用，返回 $\\operatorname{True}$ ；否则会返回 $\\operatorname{False}$。 $$\\operatorname{IsZero}:\\ \\lambda x.\\ x\\ (\\lambda t.\\ \\operatorname{False})\\ \\operatorname{True}$$ 123456auto IsZero = [](auto x) { return x([](auto /*t*/) { return False; } )(True);}; 练习¶ 实现 $\\operatorname{Mul},\\operatorname{Pow},\\operatorname{Minus}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，有 $\\operatorname{Mul}\\ x\\ y$ 表示自然数 $XY$，$\\operatorname{Pow}\\ x\\ y$ 表示自然数 $X^Y$，$\\operatorname{Minus}\\ x\\ y$ 表示自然数 $X-Y$。特殊地，对于 $X&lt;Y$ 有 $\\operatorname{Minus}\\ x\\ y=\\operatorname{Zero}$。$\\operatorname{Mul},\\operatorname{Pow},\\operatorname{Minus}$ 不需要对其他参数负责。 实现 $\\operatorname{Leq},\\operatorname{Less},\\operatorname{Eq}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$ 满足一般自然数比较关系。如 $\\operatorname{Leq}\\ \\operatorname{Three}\\ \\operatorname{Three}=\\operatorname{True}$，$\\operatorname{Less}\\ \\operatorname{Three}\\ \\operatorname{Zero}=\\operatorname{False}$。$\\operatorname{Leq},\\operatorname{Less},\\operatorname{Eq}$ 不需要对其他参数负责。 实现 $\\operatorname{Min},\\operatorname{Max}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y$，$\\operatorname{Min}\\ x\\ y$ 为表示 $X,Y$ 中的较小值的 church 数，$\\operatorname{Max}\\ x\\ y$ 为表示 $X,Y$ 中的较大值的 church 数。$\\operatorname{Min},\\operatorname{Max}$ 不需要对其他参数负责。 例 8：$\\operatorname{Div}$¶ 实现函数 $\\operatorname{Div}$，使得对于任意表示自然数 $X,Y$ 的 church 数 $x,y(y\\ne0)$，有 $\\operatorname{Div}\\ x\\ y$ 表示自然数 $\\left\\lfloor\\frac XY\\right\\rfloor$。$\\operatorname{Div}$ 不需要对其他参数负责。 考虑一个简单的除法步骤： 若 $\\operatorname{Less}\\ x\\ y$ 为 $\\operatorname{True}$，则返回 $\\operatorname{Zero}$，否则返回 $\\operatorname{Succ}\\ (\\operatorname{Div}\\ (\\operatorname{Minus}\\ x\\ y)\\ y)$。 上述操作可以通过递归实现。具体地，考虑 lambda 表达式 $$H:\\lambda f.\\ \\lambda x.\\ \\lambda y.\\ \\operatorname{Leq}\\ y\\ x\\ (f\\ f\\ (\\operatorname{Minus\\ x\\ y})\\ y\\ \\operatorname{Zero})$$ 那么将 $H$ 应用到 $H$ 上即可做递归调用，因此有 $$\\operatorname{Div}:(\\lambda f.\\ \\lambda x.\\ \\lambda y.\\ \\operatorname{Leq}\\ y\\ x\\ (f\\ f\\ (\\operatorname{Minus\\ x\\ y})\\ y\\ \\operatorname{Zero}))\\ (\\lambda f.\\ \\lambda x.\\ \\lambda y.\\ \\operatorname{Leq}\\ y\\ x\\ (f\\ f\\ (\\operatorname{Minus\\ x\\ y})\\ y\\ \\operatorname{Zero}))$$ 1234567891011121314auto Div = [](auto f) { return [=](auto x) { return [=](auto y) { return Leq(y)(x)(Succ(f(f)(Minus(x)(y))(y)))(Zero); }; };} ([](auto f) { return [=](auto x) { return [=](auto y) { return Leq(y)(x)(Succ(f(f)(Minus(x)(y))(y)))(Zero); }; };} ); 但是需要注意的是，上述代码会在编译期超出内存限制并编译失败，因为编译器不能够在编译时判断出 $\\operatorname{Div}$ 的返回类型（lambda 表达式是两两不同的）。 5. OI 中的 lambda 表达式¶ OI 中的 lambda 表达式一般只是给患有命名困难综合征和/或懒癌的选手使用的。一般情况下只有像 std::sort(a, a + n, [](int x, int y) { return b[x] &lt; b[y]; } ); 或 std::for_each(v.begin(), v.end(), [t](int &amp;x) { x += t; } ); 这种简单的语句会用到。Lambda 表达式也可以用在函数内部另外声明函数。当然，如果你一定要在非必要的地方用 lambda 表达式来声明函数我也无话可说。 6. Boost 库中的 lambda 表达式¶ Boost 库提供了另外一种 lambda 表达式的接口： 1234int i = 1; (boost::lambda::_1 += 2)(i); // i 现在为 3(std::cout &lt;&lt; ++boost::lambda::_1 &lt;&lt; std::endl)(i) // i 现在为 4，输出 4 具体可以查看此部分的官方文档，这里不再展开。","link":"/2020/07/01/notes-on-cpp-lambda-expressions/"},{"title":"题解 【洛谷 P8151 -- 彼岸 | To See the Next Part of the Dream】","text":"设长 $2^n$ 的排列的 in-shuffle 的置换为 $\\sigma_n$，求 $$\\sum_{n=l}^{r}\\sum_{i=0}^{n-1}\\operatorname{fix}\\left(\\sigma_n^i\\right).$$ 其中 $\\operatorname{fix}(\\sigma)$ 表示排列 $\\sigma$ 的不动点数目。$l\\le r\\le10^{10}$。 分别对 $N=r$ 和 $N=l-1$ 求 $$\\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\operatorname{fix}\\left(\\sigma_n^i\\right).$$ 作差后得到答案。 注意到 $\\sigma_n(t)=2t\\bmod\\left(2^n+1\\right)$，于是 $$ \\begin{aligned} \\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\operatorname{fix}\\left(\\sigma_n^i\\right)&amp;=\\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\sum_{t=1}^{2^n}\\left[2^it\\equiv t\\pmod{2^n+1}\\right]\\\\ &amp;=\\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\sum_{t=1}^{2^n}\\left[\\left(2^i-1\\right)t\\equiv 0\\pmod{2^n+1}\\right]\\\\ &amp;=\\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\sum_{t=1}^{2^n}\\left[t\\mid\\frac{2^n+1}{\\left(2^n+1,2^i-1\\right)}\\right]\\\\ &amp;=\\sum_{n=1}^{N}\\sum_{i=0}^{n-1}\\left\\lfloor\\frac{2^n\\left(2^n+1,2^i-1\\right)}{2^n+1}\\right\\rfloor\\\\ &amp;=\\sum_{n=1}^{N}\\left(2^n+\\sum_{i=1}^{n-1}\\left\\lfloor\\frac{2^n\\left(2^n+1,2^i-1\\right)}{2^n+1}\\right\\rfloor\\right)\\\\ &amp;=\\sum_{n=1}^{N}\\left(2^n+\\sum_{i=1}^{n-1}\\left(\\left(2^n+1,2^i-1\\right)-1\\right)\\right)\\\\ &amp;=\\sum_{n=1}^{N}\\left(2^n+\\sum_{i=1}^{n-1}\\left(\\left(2^n+1,2^n-2^{n-i}\\right)-1\\right)\\right)\\\\ &amp;=\\sum_{n=1}^{N}\\left(2^n+\\sum_{i=1}^{n-1}\\left(\\left(2^n+1,2^{n-i}+1\\right)-1\\right)\\right)\\\\ &amp;=\\sum_{n=1}^{N}\\left(2^n+\\sum_{i=1}^{n-1}\\left(\\left(2^n+1,2^i+1\\right)-1\\right)\\right)\\\\ &amp;=\\sum_{i=1}^{N}\\sum_{j=1}^i\\left(\\left(2^i+1,2^j+1\\right)-1\\right)\\\\ &amp;=\\sum_{i=1}^{N}\\sum_{j=1}^i2^{(i,j)}\\left[2\\nmid\\frac{ij}{(i,j)^2}\\right]\\\\ &amp;=\\sum_{d=1}^N2^d\\sum_{k=1}^{\\lfloor N/d\\rfloor}\\mu(k)\\sum_{i=1}^{\\lfloor N/dk\\rfloor}\\sum_{j=1}^i\\left[2\\nmid ijk^2\\right]\\\\ &amp;=\\sum_{d=1}^N2^d\\sum_{k=1}^{\\lfloor N/d\\rfloor}\\mu(k)[2\\nmid k]f\\left(\\left\\lfloor\\frac{N}{dk}\\right\\rfloor\\right)\\\\ &amp;=\\sum_{d=1}^N2^dg\\left(\\left\\lfloor\\frac{N}{d}\\right\\rfloor\\right). \\end{aligned} $$ 其中 $$ \\begin{gathered} g(n)=\\sum_{k=1}^n\\mu(k)[2\\nmid k]f\\left(\\left\\lfloor\\frac nk\\right\\rfloor\\right),\\\\ f(n)=\\sum_{i=1}^{n}\\sum_{j=1}^i\\left[2\\nmid ij\\right]=\\frac{\\lfloor(n+1)/2\\rfloor\\lfloor(n+3)/2\\rfloor}2. \\end{gathered} $$ 上述推导用到 定理：$\\forall i,j\\in\\mathbb N^+$ 有 $$\\left(2^i+1,2^j+1\\right)=1+2^{(i,j)}\\left[2\\nmid\\frac{ij}{(i,j)^2}\\right].$$ 其证明在文章末尾。 整除分块计算最终答案。对于 $g$ 的计算可以设阈值 $T$，对 $n\\le T$ 预处理 $g(n)$，$n&gt;T$ 时整除分块。小范围的计算直接无脑狄利克雷差分，时间复杂度 $O(T\\log\\log T)$；大范围的计算需要用到 $\\mu(k)[2\\nmid k]$ 的块筛，无脑杜教筛： $$ \\sum_{k|n}\\mu(k)[2\\nmid k]=[n\\text{ is a power of }2]. $$ 时间复杂度 $$ O\\left(T\\log\\log T+\\sum_{d=1}^{\\lfloor N/T\\rfloor}\\sqrt{\\frac Nd}\\right)=O\\left(T\\log\\log T+\\frac{N}{\\sqrt T}\\right). $$ 取 $T=\\sqrt[3]{\\left(N/\\log\\log N\\right)^2}$ 有最优时间复杂度 $O\\left(\\sqrt[3]{N^2\\log\\log N}\\right)$。有了这个阈值后可以对杜教筛的阈值稍作修改做到空间复杂度 $O\\left(\\sqrt[3]{\\left(N/\\log\\log N\\right)^2}\\right)$。 定理证明：欲求 $\\left(2^i+1,2^j+1\\right)$。若 $i=j$，则值为 $2^i+1$。否则不妨假设 $i&gt;j$。则 $$\\begin{aligned}\\left(2^i+1,2^j+1\\right)&amp;=\\left(\\left(2^i+1\\right)-2^{i-j}\\left(2^j+1\\right),2^j+1\\right)\\\\&amp;=\\left(1-2^{i-j},2^j+1\\right)\\\\&amp;=\\left(2^{i-j}-1,2^j+1\\right).\\end{aligned}$$ 欲求 $\\left(2^i+1,2^j-1\\right)$。若 $i=j$，则值为 $1$。若 $i&gt;j$，则 $$\\begin{aligned}\\left(2^i+1,2^j+1\\right)&amp;=\\left(\\left(2^i+1\\right)-2^{i-j}\\left(2^j-1\\right),2^j-1\\right)\\\\&amp;=\\left(2^{i-j}+1,2^j-1\\right).\\end{aligned}$$ 若 $i&lt;j$，则 $$\\begin{aligned}\\left(2^i+1,2^j-1\\right)&amp;=\\left(2^i+1,\\left(2^j-1\\right)-2^{j-i}\\left(2^i+1\\right)\\right)\\\\&amp;=\\left(2^i+1,-1-2^{j-i}\\right)\\\\&amp;=\\left(2^i+1,2^{j-i}+1\\right).\\end{aligned}$$ 容易发现这个过程在指数上是欧几里得算法。于是求 $\\left(2^i+1,2^j+1\\right)$ 最终一定会递归到 $2^{(i,j)}+1$ 与 $2^{(i,j)}\\pm1$ 时停止，故该值一定是 $2^{(i,j)}+1$ 或 $1$。 确定值到底是多少只需要执行上述过程求 $\\left(2^{(i,j)}+1,2^i+1\\right)$ 与 $\\left(2^{(i,j)}+1,2^j+1\\right)$ 即可。不难发现 $$\\left(2^{(i,j)}+1,2^i+1\\right)=2^{(i,j)}+1\\iff2\\nmid\\frac{i}{(i,j)}.$$ 因此 $$\\left(2^i+1,2^j+1\\right)=2^{(i,j)}+1\\iff2\\nmid\\frac{i}{(i,j)},2\\nmid\\frac{i}{(i,j)}.$$ 从而定理得证。","link":"/2022/02/12/solution-luogu-p8151/"},{"title":"题解【洛谷 P5434 -- 有标号荒漠计数】","text":"求 $n$ 个点的有标号荒漠个数。$n\\le10^5$。 为避免混淆，本文形式幂级数中未定元用 $z$ 表示。 设 荒漠的 EGF 为 $A$； 无根仙人掌的 EGF 为 $C$； 有根仙人掌的 EGF 为 $C^\\bullet$； 将唯一的 $2$ 个点的点双连通分量看作二元环，环的 EGF 为 $B$。 另外两个辅助形式幂级数 可重集 $$ E(z)=\\sum_{i=0}^{\\infty}\\frac{z^i}{i!}. $$ 单元 $$ X(z)=z. $$ 依序考察 $A$ 与 $C$ 的关系。荒漠是无根仙人掌的可重集，因此 $$ A=E\\circ C. $$ $C$ 与 $C^\\bullet$ 的关系。对仙人掌建立圆方树：仙人掌上的每一个点对应一个圆点，每个点双连通分量（环）对应一个方点，方点连接其对应的点双连通分量中所有点对应的圆点，得到一棵树。这棵树的每一条边都连接一个圆点与一个方点，且叶结点均为圆点。从而，其直径中点必定是一个点，因为其长度一定是偶数。现给圆方树任意定根，从两个角度思考： 根为圆点还是方点。若根为圆点，则此方案对应一个有根仙人掌；若根为方点，则此方案对应排列形成环的若干有根仙人掌。 根是否为圆方树直径的中点。若根为圆方树直径的中点，则此方案对应一个无根仙人掌；若根不圆方树直径的中点，则此方案对应排列形成有一个特定点的环的若干有根仙人掌（找到往直径方向的边，则有根仙人掌按照围绕方点对应的环排列，且圆点为特定点）。 容易发现以上两种对应方式均为一一对应，故有恒等式 $$ C^\\bullet+B\\circ C^\\bullet=C+\\left(XB'\\right)\\circ C^\\bullet. $$ 整理得 $$ C=\\left(X+B-XB'\\right)\\circ C^\\bullet. $$ $C^\\bullet$ 的递归关系。去掉以圆点为根的圆方树的根，得到以方点为根的圆方树的可重集，这些圆方树的根连接若干按照去掉特定点的环排列以圆点为根的圆方树，于是 $$ C^\\bullet=X\\left(E\\circ B'\\circ C^\\bullet\\right). $$ 即 $$ C^\\bullet\\circ\\frac{X}{E\\circ B'}=X. $$ 综合以上式子 $$ \\boxed{A\\circ\\frac{X}{E\\circ B'}=E\\circ\\left(X+B-XB'\\right).} $$ 剩下的就是计算。使用扩展拉格朗日反演 $$ \\begin{aligned} n!\\left[z^n\\right]A&amp;=(n-1)!\\left[z^{n-1}\\right]\\left(1+B'-B'-XB''\\right)\\left[E\\circ(X+B-XB')\\right]\\left(E\\circ B'\\right)^n\\\\ &amp;=(n-1)!\\left[z^{n-1}\\right]\\left(1-zB''(z)\\right)\\exp\\left(z+B(z)-zB'(z)+nB'(z)\\right). \\end{aligned} $$ 令 $$ T(z)=\\exp\\left(z+B(z)-zB'(z)+nB'(z)\\right). $$ 求导知 $$ T'(z)=\\left(1-zB''(z)+nB''(z)\\right)T(z). $$ 计算有 $$ \\begin{gathered} B(z)=\\frac{z^2}2+\\sum_{i=3}^{\\infty}\\frac{(i-1)!}{2i!}z^i=\\frac{-2z+z^2-2\\ln(1-z)}4.\\\\ B'(z)=\\frac{2z-z^2}{2-2z}.\\\\ B''(z)=\\frac{2-2z+z^2}{2(1-z)^2}. \\end{gathered} $$ 带入化简 $$ T'(z)=\\frac{(2n+2)-(2n+6)z+(n+4)z^2-z^3}{2(1-z)^2}T(z). $$ 容易在 $O(n)$ 时空复杂度内递推求得 $T$ 的最低 $n$ 项系数，所以原问题可以在 $O(n)$ 的时空复杂度内解决。","link":"/2022/01/06/solution-luogu-p5434/"},{"title":"题解 【洛谷 P7843 -- 「PMOI-4」猜排列】","text":"题意较长，详见题目链接。 观察 $m_2$ 与 $n$ 的关系，猜测限制为 $m_2\\approx\\log_2n$，于是往二分这个方向考虑。 令 $m=\\lceil n/2\\rceil$，很自然的思路是通过一次询问 2 确定 $[1,m]$ 与 $(m,n]$ 在排列中的位置，于是前一半就是一个相似的问题，递归求解。而对于后一半受 $m_2$ 的限制只能使用询问 1，因此去观察取模的性质。由此发现：对于 $x\\in(m,n]$ 有 $x\\bmod m=x-m$ 且这些 $x-m$ 两两不同。根据这一点，我们只需要依次询问 $(m,n]$ 所在位置的值除以 $m$ 的余数即可。 但是直接这样做会超过 $m_2$ 的限制 $1$，因此可以不做最后一次递归，此时 $n=3$ 或 $n=4$。对于 $n=3$，我们可以知道 $3$ 所在的位置，而 $3$ 除以 $1$ 和 $2$ 的余数不同，所以使用一次询问 1 求出 $1,2$ 分别所在的位置；对于 $n=4$，由于 $3\\bmod 1=4\\bmod1=4\\bmod2=0$ 而 $3\\bmod 2=1$，所以找到询问 1 回答为 $1$ 的那一对来确定 $1,2,3,4$ 每个数所在的位置。 简单计算一下发现这样做足以通过此题：$m_1&lt;n$，$m_2=\\lceil\\log_2n-1\\rceil$，$m_3&lt;2n$。 实际上我们还可以针对询问 2 的次数做进一步优化：在递归到需要求解的长度 $n$ 小于等于特定的长度 $k$ 时停止递归并使用其他方法计算出 $n$ 的位置，比如只做一次询问 2。由于上层递归仅依赖于 $n$ 的具体位置，所以如此优化足以让我们知道不小于 $n$ 的所有数的具体位置。然而只用一次询问 2 无法让我们知道小于 $n$ 的值的具体位置。结合以上两点，不难想到用一个大数 $l$ 依次去对这些小于 $n$ 的数所在的位置做询问 1 并得到不同结果，从而确定这些位置的具体值。具体地，$l\\bmod 1$ 肯定是 $0$，因此 $l\\bmod 2$ 需要是 $1$，$l\\bmod 3$ 需要是 $2$，依次类推，不难发现最小的 $l=\\operatorname{lcm}(1,2,3,\\dots,k-1)-1\\le n$。 找到最大的 $k$，则询问 2 的次数为 $\\lceil \\log_2n-\\log_2k+1\\rceil$，在 $n=5\\times10^4$ 时只需要 $13$ 次询问。 以下代码在 $n=5\\times10^4$ 时 $m_1=49986$，$m_2=13$，$m_3=99979$。肯定存在这三个数值都更优的代码，因此仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;typedef std::vector&lt;int&gt; vector;int o = 1;vector pos;int query(int x, int y) { int l; printf(&quot;! %d %d\\n&quot;, x, y); fflush(stdout); scanf(&quot;%d&quot;, &amp;l); return l;}void query(int m, int h, int e, const vector &amp;a, vector &amp;b) { int l = 0; if (m &gt; 1) { printf(&quot;? %d&quot;, m - 1); for (int i = 1; i &lt; m; ++i) printf(&quot; %d&quot;, a[i]); printf(&quot; %d\\n&quot;, h + 1); fflush(stdout); scanf(&quot;%d&quot;, &amp;l); b.resize(l); for (int &amp;x : b) scanf(&quot;%d&quot;, &amp;x); } if (l + e &lt; m) b.push_back(a[0]); std::sort(b.begin(), b.end());}#define exclude(a, b, c) std::set_difference(a.begin(), a.end(), b.begin(), b.end(), c)void solve(int m, const vector &amp;ind) { int h = 0; vector hi; if (m &lt;= o * 2) { h = o; vector inc; query(m, o - 1, o - 1, ind, inc); query(m - o + 1, o, 1, inc, hi); exclude(inc, hi, &amp;pos[o]); } else { h = (m + 1) &gt;&gt; 1; vector lo(h); query(m, h, h, ind, hi); exclude(ind, hi, lo.begin()); solve(h, lo); } for (int i = 1; i &lt; m - h; ++i) { int p = query(hi[i], pos[h]) + h; if (p &lt;= h) p += h; pos[p] = hi[i]; } for (int i = h + 1; i &lt;= m; ++i) if (!pos[i]) { pos[i] = hi[0]; break; }}int gcd(int x, int y) { while (y) { const int z = x % y; x = y; y = z; } return x;}int main() { int n; scanf(&quot;%d%*d%*d%*d&quot;, &amp;n); vector ind(n); for (int i = 0; i &lt; n; ++i) ind[i] = i + 1; if (n == 4) { vector lo(2), hi; query(4, 2, 2, ind, hi); exclude(ind, hi, lo.begin()); ind.resize(n + 1); if (query(hi[0], lo[0])) { ind[hi[0]] = 3; ind[hi[1]] = 4; ind[lo[0]] = 2; ind[lo[1]] = 1; } else if (query(hi[0], lo[1])) { ind[hi[0]] = 3; ind[hi[1]] = 4; ind[lo[0]] = 1; ind[lo[1]] = 2; } else if (query(hi[1], lo[0])) { ind[hi[0]] = 4; ind[hi[1]] = 3; ind[lo[0]] = 2; ind[lo[1]] = 1; } else { ind[hi[0]] = 4; ind[hi[1]] = 3; ind[lo[0]] = 1; ind[lo[1]] = 2; } } else { int v = 1; while (true) { ++o; const int u = v * o / gcd(v, o); if (u &gt; n + 1) break; v = u; } pos.resize(n + 1); solve(n, ind); ind.assign(n + 1, 0); for (int i = 1; i &lt;= n; ++i) ind[pos[i]] = i; int fir = 0; for (int i = 1; i &lt;= n; ++i) if (!ind[i]) { if (!fir) { fir = i; } else { ind[i] = query(pos[v - 1], i) + 1; pos[ind[i]] = i; } } if (fir) { for (int i = 1; i &lt;= n; ++i) if (!pos[i]) { ind[fir] = i; break; } } } putchar('A'); for (int i = 1; i &lt;= n; ++i) printf(&quot; %d&quot;, ind[i]); fflush(stdout); return 0;}","link":"/2021/08/21/solution-luogu-p7843/"},{"title":"题解 【JOISC 2021 Day2 -- 道路の建設案】","text":"给定平面上 $n$ 个点 $\\left(x_i,y_i\\right)$，求曼哈顿距离前 $k$ 小的无序点对。 $2\\le n\\le2.5\\times10^5$，$1\\le k\\le\\min\\left(2.5\\times 10^5,\\ \\dfrac{n\\cdot(n-1)}{2}\\right)$，$\\left|x_i\\right|,\\left|y_i\\right|\\le10^9$。 设定阈值 $m\\ge k$。二分距离 $d$ 并求出曼哈顿距离小于等于 $d$ 的点对的距离。求这些距离的过程中一旦发现点对个数超过 $m$ 就立刻退出并缩小 $d$；如果点对个数不到 $k$ 就增大 $d$；否则选择前 $k$ 小距离即可。假设 $\\left|x_i\\right|,\\left|y_i\\right|\\le a$，那么使用数组存储这些距离并最后求出前 $k$ 小可以做到时间复杂度 $O\\left(\\left(n\\log n+m\\right)\\log a+k\\log k\\right)$，空间复杂度 $O\\left(n+m\\right)$ ；使用堆动态维护前 $k$ 小可以做到时间复杂度 $O\\left(\\left(n\\log n+m\\log k\\right)\\log a\\right)$，空间复杂度 $O\\left(n+k\\right)$。理论上 $m=k$ 时最优，但是值得注意的是 $m$ 增大时，二分的次数就会相应地减小。 关于二分距离 $d$ 后求出曼哈顿距离小于等于 $d$ 的点对：可以转化为切比雪夫距离后将点按照横坐标为第一关键字，纵坐标为第二关键字排序，然后使用双指针得到横坐标在范围内的其他点。维护按照纵坐标排序的 std::set，那么只需要依序遍历纵坐标也在范围内的点即可。","link":"/2021/05/01/solution-joisc2021-road-construction/"},{"title":"题解【NOI Online 2021 提高组 -- 岛屿探险】","text":"给两个长 $n$ 的数列 $a,b$，$q$ 次询问，每次询问给出 $l_i,r_i,c_i,d_i$，求有多少个 $j$ 满足 $l_i\\le j\\le r_i$ 且 $(a_j\\oplus c_i)\\le\\min(b_j,d_i)$。 $1\\le n,q\\le10^5$，$1\\le l_i\\le r_i\\le n$，$1\\le a_i,b_i,c_i,d_i&lt;2^{24}$。 这是一篇指令集题解，不是正解。如果想要知道正解请移步其他题解。另外，不要尝试在正式 OI 竞赛中使用指令集。 我们发现这是一个序列上问题，并且 $O\\left(nq\\right)$ 暴力非常好写，于是我们考虑指令集。 我们需要能够同时对多个数判断 $(a\\oplus c)\\le\\min(b,d)$，这等价于 $(a\\oplus c)\\le b$ 且 $(a\\oplus c)\\le d$。由于 $\\oplus$，$\\le$ 与 $\\&amp;$ 都是指令集基本运算，所以我们已经做完了。 顺便借此推广一下一种（可能）更好写更好记的写法，具体可见代码。需注意布尔真值为二进制全一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma GCC target(&quot;sse&quot;, &quot;avx2&quot;)#include &lt;cstdio&gt;#include &lt;algorithm&gt;char ibuf[1 &lt;&lt; 20], obuf[1 &lt;&lt; 20];const char *sp, *ep;char *op = obuf;#define gc() (sp == ep &amp;&amp; (ep = (sp = ibuf) + fread(ibuf, 1, sizeof ibuf, stdin)), *sp++)#define flush() (fwrite(obuf, 1, op - obuf, stdout), op = obuf)#define pc(c) (op == obuf + sizeof obuf &amp;&amp; flush(), *op++ = (c))int read() { static int c, x; while ((c = gc()) &lt; 48) {} x = c &amp; 15; while ((c = gc()) &gt;= 48) x = x * 10 + (c &amp; 15); return x;}void write(const int &amp;x) { if (x &gt;= 10) write(x / 10); pc((x % 10) | 48);}typedef unsigned u256 __attribute((vector_size(32)));const int N = 100000 &gt;&gt; 3;u256 ans, cs, ds, tp;u256 a[N], b[N];int main() { const int n = read(); int q = read(); for (int i = 0; i &lt; n; ++i) { a[i &gt;&gt; 3][i &amp; 7] = read(); b[i &gt;&gt; 3][i &amp; 7] = read(); } while (q--) { const int l = read() - 1, r = read() - 1; const unsigned c = read(), d = read(); cs = u256{ c, c, c, c, c, c, c, c }; ds = u256{ d, d, d, d, d, d, d, d }; ans = u256{ 0, 0, 0, 0, 0, 0, 0, 0 }; int res = 0; if ((l &gt;&gt; 3) == (r &gt;&gt; 3)) { for (int i = l &amp; 7; i &lt;= (r &amp; 7); ++i) { res += (a[l &gt;&gt; 3][i] ^ c) &lt;= std::min(b[l &gt;&gt; 3][i], d); } } else { for (int i = l &amp; 7; i &lt;= 7; ++i) { res += (a[l &gt;&gt; 3][i] ^ c) &lt;= std::min(b[l &gt;&gt; 3][i], d); } for (int i = 0; i &lt;= (r &amp; 7); ++i) { res += (a[r &gt;&gt; 3][i] ^ c) &lt;= std::min(b[r &gt;&gt; 3][i], d); } for (int i = (l &gt;&gt; 3) + 1; i != (r &gt;&gt; 3); ++i) { tp = a[i] ^ cs; ans += (tp &lt;= b[i]) &amp; (tp &lt;= ds); } for (int i = 0; i &lt;= 7; ++i) res -= ans[i]; } write(res); pc(10); } flush(); return 0;}","link":"/2021/03/27/solution-noionline-2021-island/"},{"title":"题解【洛谷 P7119 -- Mivik 的游戏】","text":"题意较长，详见题目链接。 设当前反面朝上硬币数为 $k$ ，将所有反面的位置 $p_1,p_2,\\dots,p_k$ 从小到大排序。 显然有 $k\\le p_k$，所以一定存在一个 $i$ 使得 $p_{i-1}&lt;k,p_i\\ge k$。那么一开始翻硬币的过程一定是 $k,k+1,k+2,\\dots,p_i-1,p_i,p_i-1,p_i-2,\\dots,k+1,k$。容易发现这样操作之后 $p_i$ 上的硬币变成了正面而其他硬币不变，问题就变为了 $k$ 减小 $1$ 后的情况。所以答案不可能是 $\\texttt{never}$ 并且每个位置对答案的贡献形如 $2p_i-2j+1$。这可以拆成三部分分别计算求和，即 $$ 2\\sum_{i=1}^{k}p_i-2\\sum_{i=1}^ki+k=2\\sum_{i=1}^{k}p_i-k^2. $$ 用线段树维护 $p_i$ 之和以及 $k$ 即可。时间复杂度 $O\\left(n+m\\log n\\right)$，空间复杂度 $O\\left(n\\right)$。","link":"/2020/11/29/solution-luogu-p7119/"},{"title":"题解 【洛谷 P7122 -- Chino 与线段树】","text":"设 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，给定 $a,b$，求 $$\\sum_{n=a}^{b}f(n).$$ $1\\le a\\le b\\le10^{10^6}$。 设 $d\\left(n\\right)$ 表示一棵 $n$ 个叶子结点的线段树的深度，那么有 $d\\left(1\\right)=1$ 与 $$ \\begin{aligned} d\\left(2n\\right)&amp;=d\\left(n\\right)+1,\\\\ d\\left(2n+1\\right)&amp;=\\max\\left\\{d\\left(n+1\\right),d\\left(n\\right)\\right\\}+1. \\end{aligned} $$ 所以 $$ d\\left(n\\right)=\\left\\lceil\\log n\\right\\rceil+1. $$ 我们又有 $$ \\begin{aligned} f\\left(2n\\right)&amp;=2^{d\\left(n\\right)+1}+f\\left(n\\right),\\\\ f\\left(2n+1\\right)&amp;=\\begin{cases} 2^{d\\left(n\\right)}+f\\left(n+1\\right), &amp;d\\left(n+1\\right)&gt;d\\left(n\\right),\\\\ 2^{d\\left(n\\right)+1}+f\\left(n\\right), &amp;d\\left(n+1\\right)\\le d\\left(n\\right). \\end{cases} \\end{aligned} $$ 按 $n$ 的二进制位从高位向低位递推。发现 $d\\left(n+1\\right)&gt;d\\left(n\\right)$ 当且仅当 $n=2^k\\left(k\\in\\N\\right)$，因此 $n$ 最高 $\\texttt1$ 位后的全 $\\texttt0$ 段这一部分的答案可以直接计算，之后的 $\\texttt1$ 位就一定是第二种情况，于是第一段全 $\\texttt0$ 位后的 $\\texttt0$ 位就与 $\\texttt1$ 位一样了。 有了这点，我们就容易发现 $$ f\\left(n\\right)=\\begin{cases} 2^{x+1}-1, &amp;n=2^x\\left(x\\in\\N\\right),\\\\ 2^{x+2}-2^{x-y+1}+1, &amp;n=2^x+2^y+t\\left(x,y\\in\\N,0\\le t&lt;2^y&lt;2^x\\right). \\end{cases} $$ 现在我们要对 $f$ 求和。我们可以分别求出 $n=1,2,3,\\dots,b$ 时的和与 $n=1,2,3,\\dots,a-1$ 时的和，然后作差得出答案，所以我们现在要对于 $N=a-1$ 和 $N=b$ 求 $$ \\sum_{n=1}^Nf\\left(n\\right). $$ 若 $N=2^X\\left(X\\in\\N\\right)$，那么我们单独计算 $f\\left(N\\right)$ 然后并计算 $N$ 减去一后的答案，求和就可以得到答案。所以我们假设 $N=2^X+2^Y+T\\left(X,Y\\in\\N,0\\le T&lt;2^Y&lt;2^X\\right)$，那么 $$ \\begin{aligned} \\sum_{n=1}^Nf\\left(n\\right)=&amp;\\sum_{x=0}^{X-1}\\left(2^{x+1}-1+\\sum_{y=0}^{x-1}2^y\\left(2^{x+2}-2^{x-y+1}+1\\right)\\right)+2^{X+1}-1\\\\ &amp;\\qquad+\\sum_{y=0}^{Y-1}2^y\\left(2^{X+2}-2^{X-y+1}+1\\right)+\\left(T+1\\right)\\left(2^{X+2}-2^{X-Y+1}+1\\right)\\\\ =&amp;3\\times2^X-2^{X+1}X-2X+\\frac{2^{2X+2}-13}3+2^{X+1}-1\\\\ &amp;\\qquad+\\left(2^{X+2}+1\\right)\\left(2^Y-1\\right)-Y\\times2^{X+1}+\\left(T+1\\right)\\left(2^{X+2}-2^{X-Y+1}+1\\right). \\end{aligned} $$ 于是就可以计算了。你可能需要一个高精度板子。时间复杂度 $\\sout{O\\left(\\log b\\log\\log b\\right)}$，空间复杂度 $\\sout{O\\left(\\log b\\right)}$。人生苦短，我用 Ruby。","link":"/2020/11/29/solution-luogu-p7122/"},{"title":"题解【洛谷 P7120 -- Chino 的比赛】","text":"对于置换 $\\pi$，令 $\\nu\\left(\\pi\\right)$ 表示其不动点个数，设 $\\upsilon\\left(\\pi\\right)$ 为其能够被分解成为的最少个数对换乘积的对换数目。设 $n$ 元对称群为 $S_n$，$n$ 元交错群为 $A_n$，求 $$2\\sum_{\\pi\\in S_n\\land\\pi\\notin A_n}\\frac{\\upsilon\\left(\\pi\\right)}{\\nu\\left(\\pi\\right)+1}\\mod p.$$ $1\\le n\\le2\\times10^7$，$2^{25}&lt;p&lt;2^{31}$。 设答案为 $2f_n$。枚举 $\\nu\\left(\\pi\\right)$，对 $\\upsilon\\left(\\pi\\right)$ 使用二项式反演求和，可以得到 $$ \\begin{aligned} f_n&amp;=\\sum_{i=0}^{n}\\frac{1}{i+1}\\binom{n}{i}\\sum_{j=0}^{n-i}\\left(-1\\right)^{j}\\binom{n-i}{j}\\sum_{\\pi\\in S_{n-i-j}\\land\\pi\\notin A_{n-i-j}}\\upsilon\\left(\\pi\\right)\\\\ &amp;=\\sum_{i=0}^{n}\\frac{\\left(-1\\right)^i}{i+1}\\binom{n}{i}\\sum_{\\pi\\in S_{n-i}\\land\\pi\\notin A_{n-i}}\\upsilon\\left(\\pi\\right). \\end{aligned} $$ 现在我们只需要对于所有 $n$ 求出 $$ p_n=\\sum_{\\pi\\in S_n\\land\\pi\\notin A_n}\\upsilon\\left(\\pi\\right). $$ 于是我们假设 $$ a_n=\\sum_{\\pi\\in A_n}\\upsilon\\left(\\pi\\right). $$ 显然有 $a_1=p_1=0$。对于 $n&gt;1$，讨论 $\\pi\\left(n\\right)$ 是否为 $n$ 可以得到 $$ \\begin{gathered} a_n=a_{n-1}+\\left(n-1\\right)\\left(\\left\\lfloor\\frac{\\left(n-1\\right)!}{2}\\right\\rfloor+p_{n-1}\\right).\\\\ p_n=p_{n-1}+\\left(n-1\\right)\\left(\\left\\lceil\\frac{\\left(n-1\\right)!}{2}\\right\\rceil+a_{n-1}\\right). \\end{gathered} $$ 直接递推即可。时间复杂度 $O\\left(n\\right)$。空间复杂度可以分段线性求逆做到 $O(\\log p)$。 另外，继续使用生成函数推导可以得到： $$ f_n=n!\\left[x^n\\right]\\frac{\\left(1-e^{-x}\\right)\\left(\\left(1-x\\right)^2\\left(1+x\\right)\\ln\\left(1+x\\right)+\\left(1-x\\right)\\ln\\left(1-x\\right)+\\left(2-x\\right)x^2\\right)}{2x\\left(1-x\\right)^2}. $$","link":"/2020/11/29/solution-luogu-p7120/"},{"title":"题解 【COCI2006-2007#4 -- JOGURT】","text":"构造一个结点权值分别为 $1,2,\\dots,2^{n-1}$ 的深度为 $n$ 的完全二叉树，使得对于所有 $d=0,1,\\dots,n-1$ 而言，每个深度为 $d$ 的点左右子树的权值和的差的绝对值为 $2^d$。 $n\\le15$。 构造一棵二叉树：深度为 $d$ 每个结点的左右儿子的值（而非左右子树的和）的差（而非差的绝对值）为 $-2^d$。这样的二叉树是唯一的。 考虑将第 $(n-1)$ 层的结点权值翻转。对于一个在翻转过后的树上深度为 $d$ 的结点 $(0\\le d&lt;n-1)$，其左右子树的权值和的差值为 $-2^d\\times(2^{n-d-2}-1)+2^d\\times2^{n-d-2}=2^d$（即左右子树中非叶子结点的差与左右子树中叶子结点的差的和），其绝对值为 $2^d$，因此这是一个合法的构造方案。 例如对于 $n=5$ 的构造方案（添加了前导零）： 123456789 01 02 03 04 06 05 07 08 12 10 14 09 13 11 1531 23 27 19 29 21 25 17 30 22 26 18 28 20 24 16 具体可以自行画图理解或者参考代码。输出部分复杂度不可忽略，总时间复杂度 $O(n\\times2^n)$。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;int n;int val[1 &lt;&lt; 15];void build(int o, int d, int v) { if (d == n) return; val[o] = v; build(o &lt;&lt; 1, d + 1, v + (1 &lt;&lt; d)); build(o &lt;&lt; 1 | 1, d + 1, v + (1 &lt;&lt; (d + 1)));}void print(int o, int d) { if (d == n) return; printf(&quot;%d &quot;, val[o]); print(o &lt;&lt; 1, d + 1); print(o &lt;&lt; 1 | 1, d + 1);}int main() { scanf(&quot;%d&quot;, &amp;n); build(1, 0, 1); std::reverse(val + (1 &lt;&lt; (n - 1)), val + (1 &lt;&lt; n)); print(1, 0); return 0;}","link":"/2020/07/03/solution-coci2006-2007-4-jogurt/"},{"title":"题解【洛谷 P6021 -- 洪水】","text":"给定一棵 $n$ 个点的有根树，点有点权。$q$ 次操作，每次操作修改一个点的权值，或者给一个点并只考虑以该点为根的最大子树，在这个子树中删去一些点使得每个叶子结点都与根不连通，删去的点的权值和的最小值。 $n,m\\le2\\times10^5$，点权始终不超过 $2\\times10^9$。 在从 DP 和带修这两点看出来这道题可以使用动态 DP 后，可以根据套路，先列出无修改操作时的 DP 式： $$f_x=\\min(val_x,\\sum_{i\\in son_x}f_i).$$ 然后把 $\\displaystyle\\sum_{i\\in son_x}f_i$ 分成轻重儿子，即设 $$g_x=\\sum_{i\\in son_x,i\\neq hson_x}f_i.$$ 则有 $$f_x=\\min(val_x,g_x+f_{hson_x}).$$ 特别地，如果 $son_x=\\varnothing$，则令 $g_x=+\\infty$ 来避免后面那种情况的转移。 写成广义矩阵乘法的形式，有 $$\\begin{pmatrix}g_x&amp;val_x\\\\0&amp;0\\end{pmatrix}\\begin{pmatrix}f_{hson_x}\\\\0\\end{pmatrix}=\\begin{pmatrix}f_x\\\\0\\end{pmatrix}.$$ 注意到这里的乘法是相加取 $\\min$。 于是 $g_x$ 暴力上传，再用全局平衡二叉树维护一下 $\\begin{pmatrix}g_x&amp;val_x\\\\0&amp;0\\end{pmatrix}$ 在重链上的连乘积就可以了。 可是发现一个问题：由于模板是询问一整棵树，所以可以直接使用全局平衡二叉树树根的矩阵的值；然而这道题要询问子树，那咋办哪？ 观察全局平衡二叉树的性质，发现对于去掉虚边的每一棵子树，它前序遍历的结果就是原树上由浅到深的一条重链。那么，我们需要查询的实际上就是前序遍历的一个后缀所对应的矩阵的乘积，也就是查询结点所在二叉树上靠右的一部分。 于是，我们可以用类似线段树的形式：若查询结点在所在全局平衡二叉树当前子树的右子树内，则递归进入右子树；若为当前结点，则直接返回当前结点的矩阵乘以右子树的连乘矩阵；否则左子树递归查询，然后返回与当前结点的矩阵与右子树的连乘矩阵的乘积即可。写成代码不难： 1234567891011// w 代表该结点对应的矩阵，mul 代表结点所在子树的矩阵连乘积，dep 代表结点在原树中的深度// lc 代表在全局平衡二叉树上的左儿子，rc 代表在全局平衡二叉树上的右儿子// rt 代表当前遍历到的结点，x 代表查询的结点mat query(int rt, int x) { // rt 的深度小于 x 的深度说明 x 在 rt 的右子树内 // 因为前序遍历是由浅到深的，也就是说这种情况 rt 在 x 前面 // 可以画图理解 if (dep[rt] &lt; dep[x]) return query(rc[rt], x); if (rt == x) return w[rt] * mul[rc[x]]; return query(lc[rt], x) * w[rt] * mul[rc[rt]];} 由于全局平衡二叉树的总深度是 $\\mathcal O(\\log n)$ 的，所以显然去掉虚边后的每一棵二叉树的深度上界是 $\\mathcal O(\\log n)$ 的，只有一条重链时达到最坏情况，因此这个查询的复杂度是 $\\mathcal O(\\log n)$ 的，与修改复杂度相同。 那么我们最终就能够在 $\\mathcal O(n+m\\log n)$ 的时间内解决这个问题，复杂度吊打树链剖分，常数吊打 LCT。 又注意到 $$\\begin{pmatrix}a&amp;b\\\\0&amp;0\\end{pmatrix}\\begin{pmatrix}c&amp;d\\\\0&amp;0\\end{pmatrix}=\\begin{pmatrix}\\min(a+c,b)&amp;\\min(a+d,b)\\\\0&amp;0\\end{pmatrix}.$$ 因此在存储矩阵时只需要存储两个位置的值即可： 12345678struct mat { long long a00, a01; inline mat() : a00(0), a01(INF) {} inline mat(long long a00, long long a01) : a00(a00), a01(a01) {} friend inline mat operator*(const mat &amp;x, const mat &amp;y) { return mat(min(x.a00 + y.a00, x.a01), min(x.a00 + y.a01, x.a01)); }}","link":"/2020/03/07/solution-luogu-p6021/"}],"tags":[{"name":"Language","slug":"Language","link":"/tags/Language/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Constructive","slug":"Constructive","link":"/tags/Constructive/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Data Structures","slug":"Data-Structures","link":"/tags/Data-Structures/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Segment Tree","slug":"Segment-Tree","link":"/tags/Segment-Tree/"},{"name":"Discrete Fourier Transform","slug":"Discrete-Fourier-Transform","link":"/tags/Discrete-Fourier-Transform/"},{"name":"Brute Force","slug":"Brute-Force","link":"/tags/Brute-Force/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Computer Science","slug":"Study/Computer-Science","link":"/categories/Study/Computer-Science/"},{"name":"Competitive Programming","slug":"Study/Competitive-Programming","link":"/categories/Study/Competitive-Programming/"},{"name":"Discrete Math","slug":"Study/Discrete-Math","link":"/categories/Study/Discrete-Math/"}]}